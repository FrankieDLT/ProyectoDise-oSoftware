<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>Metaprogramming</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Metaprogramming</h1>
<div class="details">
<span id="revnumber">version 3.0.3</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_runtime_metaprogramming">1. Runtime metaprogramming</a>
<ul class="sectlevel2">
<li><a href="#_groovyobject_interface">1.1. GroovyObject interface</a>
<ul class="sectlevel3">
<li><a href="#_invokemethod">1.1.1. invokeMethod</a></li>
<li><a href="#_get_setproperty">1.1.2. get/setProperty</a></li>
<li><a href="#_get_setmetaclass">1.1.3. get/setMetaClass</a></li>
</ul>
</li>
<li><a href="#_get_setattribute">1.2. get/setAttribute</a></li>
<li><a href="#_methodmissing">1.3. methodMissing</a></li>
<li><a href="#_propertymissing">1.4. propertyMissing</a></li>
<li><a href="#_static_methodmissing">1.5. static methodMissing</a></li>
<li><a href="#_static_propertymissing">1.6. static propertyMissing</a></li>
<li><a href="#_groovyinterceptable">1.7. GroovyInterceptable</a></li>
<li><a href="#categories">1.8. Categories</a></li>
<li><a href="#_metaclasses">1.9. Metaclasses</a>
<ul class="sectlevel3">
<li><a href="#_the_default_metaclass_code_metaclassimpl_code">1.9.1. The default metaclass <code>MetaClassImpl</code></a></li>
<li><a href="#_custom_metaclasses">1.9.2. Custom metaclasses</a>
<ul class="sectlevel4">
<li><a href="#_delegating_metaclass">Delegating metaclass</a></li>
<li><a href="#_magic_package">Magic package</a></li>
</ul>
</li>
<li><a href="#_per_instance_metaclass">1.9.3. Per instance metaclass</a></li>
<li><a href="#metaprogramming_emc">1.9.4. ExpandoMetaClass</a>
<ul class="sectlevel4">
<li><a href="#_methods">Methods</a></li>
<li><a href="#_properties">Properties</a></li>
<li><a href="#_constructors">Constructors</a></li>
<li><a href="#_static_methods">Static Methods</a></li>
<li><a href="#_borrowing_methods">Borrowing Methods</a></li>
<li><a href="#_dynamic_method_names">Dynamic Method Names</a></li>
<li><a href="#_runtime_discovery">Runtime Discovery</a></li>
<li><a href="#_groovyobject_methods">GroovyObject Methods</a></li>
<li><a href="#_overriding_static_invokemethod">Overriding Static invokeMethod</a></li>
<li><a href="#_extending_interfaces">Extending Interfaces</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_extension_modules">1.10. Extension modules</a>
<ul class="sectlevel3">
<li><a href="#_extending_existing_classes">1.10.1. Extending existing classes</a></li>
<li><a href="#_instance_methods">1.10.2. Instance methods</a></li>
<li><a href="#_static_methods_2">1.10.3. Static methods</a></li>
<li><a href="#module-descriptor">1.10.4. Module descriptor</a></li>
<li><a href="#_extension_modules_and_classpath">1.10.5. Extension modules and classpath</a></li>
<li><a href="#_compatibility_with_type_checking">1.10.6. Compatibility with type checking</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_compile_time_metaprogramming">2. Compile-time metaprogramming</a>
<ul class="sectlevel2">
<li><a href="#_available_ast_transformations">2.1. Available AST transformations</a>
<ul class="sectlevel3">
<li><a href="#_code_generation_transformations">2.1.1. Code generation transformations</a>
<ul class="sectlevel4">
<li><a href="#xform-ToString"><code>@groovy.transform.ToString</code></a></li>
<li><a href="#xform-EqualsAndHashCode"><code>@groovy.transform.EqualsAndHashCode</code></a></li>
<li><a href="#xform-TupleConstructor"><code>@groovy.transform.TupleConstructor</code></a></li>
<li><a href="#_implementation_details">Implementation Details</a></li>
<li><a href="#_immutability_support">Immutability support</a></li>
<li><a href="#_customization_options">Customization options</a></li>
<li><a href="#xform-MapConstructor"><code>@groovy.transform.MapConstructor</code></a></li>
<li><a href="#xform-Canonical"><code>@groovy.transform.Canonical</code></a></li>
<li><a href="#xform-InheritConstructors"><code>@groovy.transform.InheritConstructors</code></a></li>
<li><a href="#xform-Category"><code>@groovy.lang.Category</code></a></li>
<li><a href="#xform-IndexedProperty"><code>@groovy.transform.IndexedProperty</code></a></li>
<li><a href="#xform-Lazy"><code>@groovy.lang.Lazy</code></a></li>
<li><a href="#xform-Newify"><code>@groovy.lang.Newify</code></a></li>
<li><a href="#xform-Sortable"><code>@groovy.transform.Sortable</code></a></li>
<li><a href="#xform-Builder"><code>@groovy.transform.builder.Builder</code></a></li>
<li><a href="#xform-AutoImplement"><code>@groovy.transform.AutoImplement</code></a></li>
<li><a href="#xform-NullCheck"><code>@groovy.transform.NullCheck</code></a></li>
</ul>
</li>
<li><a href="#_class_design_annotations">2.1.2. Class design annotations</a>
<ul class="sectlevel4">
<li><a href="#xform-BaseScript"><code>@groovy.transform.BaseScript</code></a></li>
<li><a href="#xform-Delegate"><code>@groovy.lang.Delegate</code></a></li>
<li><a href="#xform-Immutable"><code>@groovy.transform.Immutable</code></a></li>
<li><a href="#xform-ImmutableBase"><code>@groovy.transform.ImmutableBase</code></a></li>
<li><a href="#xform-PropertyOptions"><code>@groovy.transform.PropertyOptions</code></a></li>
<li><a href="#xform-VisibilityOptions"><code>@groovy.transform.VisibilityOptions</code></a></li>
<li><a href="#xform-ImumtableOptions"><code>@groovy.transform.ImmutableOptions</code></a></li>
<li><a href="#xform-KnownImmutable"><code>@groovy.transform.KnownImmutable</code></a></li>
<li><a href="#xform-Memoized"><code>@groovy.transform.Memoized</code></a></li>
<li><a href="#xform-TailRecursive"><code>@groovy.transform.TailRecursive</code></a></li>
<li><a href="#xform-Singleton"><code>@groovy.lang.Singleton</code></a></li>
<li><a href="#xform-Mixin"><code>@groovy.lang.Mixin</code></a></li>
</ul>
</li>
<li><a href="#_logging_improvements">2.1.3. Logging improvements</a>
<ul class="sectlevel4">
<li><a href="#xform-Log"><code>@groovy.util.logging.Log</code></a></li>
<li><a href="#xform-Commons"><code>@groovy.util.logging.Commons</code></a></li>
<li><a href="#xform-Log4j"><code>@groovy.util.logging.Log4j</code></a></li>
<li><a href="#xform-Log4j2"><code>@groovy.util.logging.Log4j2</code></a></li>
<li><a href="#xform-Slf4j"><code>@groovy.util.logging.Slf4j</code></a></li>
</ul>
</li>
<li><a href="#_declarative_concurrency">2.1.4. Declarative concurrency</a>
<ul class="sectlevel4">
<li><a href="#xform-Synchronized"><code>@groovy.transform.Synchronized</code></a></li>
<li><a href="#xform-WithReadLock"><code>@groovy.transform.WithReadLock</code> and <code>@groovy.transform.WithWriteLock</code></a></li>
</ul>
</li>
<li><a href="#_easier_cloning_and_externalizing">2.1.5. Easier cloning and externalizing</a>
<ul class="sectlevel4">
<li><a href="#xform-AutoClone"><code>@groovy.transform.AutoClone</code></a></li>
<li><a href="#xform-AutoExternalize"><code>@groovy.transform.AutoExternalize</code></a></li>
</ul>
</li>
<li><a href="#_safer_scripting">2.1.6. Safer scripting</a>
<ul class="sectlevel4">
<li><a href="#xform-ThreadInterrupt"><code>@groovy.transform.ThreadInterrupt</code></a></li>
<li><a href="#xform-TimedInterrupt"><code>@groovy.transform.TimedInterrupt</code></a></li>
<li><a href="#xform-ConditionalInterrupt"><code>@groovy.transform.ConditionalInterrupt</code></a></li>
</ul>
</li>
<li><a href="#_compiler_directives">2.1.7. Compiler directives</a>
<ul class="sectlevel4">
<li><a href="#xform-Field"><code>@groovy.transform.Field</code></a></li>
<li><a href="#xform-PackageScope"><code>@groovy.transform.PackageScope</code></a></li>
<li><a href="#xform-AutoFinal"><code>@groovy.transform.AutoFinal</code></a></li>
<li><a href="#xform-AnnotationCollector"><code>@groovy.transform.AnnotationCollector</code></a></li>
<li><a href="#xform-TypeChecked"><code>@groovy.transform.TypeChecked</code></a></li>
<li><a href="#xform-CompileStatic"><code>@groovy.transform.CompileStatic</code></a></li>
<li><a href="#xform-CompileDynamic"><code>@groovy.transform.CompileDynamic</code></a></li>
<li><a href="#xform-DelegatesTo"><code>@groovy.lang.DelegatesTo</code></a></li>
<li><a href="#xform-SelfType"><code>@groovy.transform.SelfType</code></a></li>
</ul>
</li>
<li><a href="#_swing_patterns">2.1.8. Swing patterns</a>
<ul class="sectlevel4">
<li><a href="#xform-Bindable"><code>@groovy.beans.Bindable</code></a></li>
<li><a href="#xform-ListenerList"><code>@groovy.beans.ListenerList</code></a></li>
<li><a href="#xform-Vetoable"><code>@groovy.beans.Vetoable</code></a></li>
</ul>
</li>
<li><a href="#_test_assistance">2.1.9. Test assistance</a>
<ul class="sectlevel4">
<li><a href="#xform-NotYetImplemented"><code>@groovy.test.NotYetImplemented</code></a></li>
<li><a href="#xform-ASTTest"><code>@groovy.transform.ASTTest</code></a></li>
</ul>
</li>
<li><a href="#_grape_handling">2.1.10. Grape handling</a>
<ul class="sectlevel4">
<li><a href="#xform-Grab"><code>@groovy.lang.Grab</code></a></li>
<li><a href="#xform-GrabConfig"><code>@groovy.lang.GrabConfig</code></a></li>
<li><a href="#xform-GrabExclude"><code>@groovy.lang.GrabExclude</code></a></li>
<li><a href="#xform-GrabResolver"><code>@groovy.lang.GrabResolver</code></a></li>
<li><a href="#xform-Grapes"><code>@groovy.lang.Grapes</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#developing-ast-xforms">2.2. Developing AST transformations</a>
<ul class="sectlevel3">
<li><a href="#_compilation_phases_guide">2.2.1. Compilation phases guide</a></li>
<li><a href="#transforms-local">2.2.2. Local transformations</a></li>
<li><a href="#transforms-global">2.2.3. Global transformations</a></li>
<li><a href="#_ast_api_guide">2.2.4. AST API guide</a>
<ul class="sectlevel4">
<li><a href="#_abstractasttransformation">AbstractASTTransformation</a></li>
<li><a href="#_classcodeexpressiontransformer">ClassCodeExpressionTransformer</a></li>
<li><a href="#_ast_nodes">AST Nodes</a></li>
</ul>
</li>
<li><a href="#_macros">2.2.5. Macros</a>
<ul class="sectlevel4">
<li><a href="#_introduction">Introduction</a></li>
<li><a href="#_statements_and_expressions">Statements and expressions</a></li>
<li><a href="#_variable_substitution">Variable substitution</a></li>
<li><a href="#_macroclass">MacroClass</a></li>
<li><a href="#_macro_methods">@Macro methods</a></li>
</ul>
</li>
<li><a href="#_testing_ast_transformations">2.2.6. Testing AST transformations</a>
<ul class="sectlevel4">
<li><a href="#_separating_source_trees">Separating source trees</a></li>
<li><a href="#_debugging_ast_transformations">Debugging AST transformations</a></li>
<li><a href="#_astmatcher">ASTMatcher</a></li>
<li><a href="#_asttest">ASTTest</a></li>
</ul>
</li>
<li><a href="#_external_references">2.2.7. External references</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The Groovy language supports two flavors of metaprogramming: runtime and compile-time.
The first allows altering the class model and the behavior of a program at runtime while the second only occurs
at compile-time. Both have pros and cons that we will detail in this section.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_runtime_metaprogramming"><a class="anchor" href="#_runtime_metaprogramming"></a>1. Runtime metaprogramming</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With runtime metaprogramming we can postpone to runtime the decision to intercept, inject and even synthesize methods of classes and interfaces. For a deep understanding of Groovy&#8217;s metaobject protocol (MOP) we need to understand Groovy objects and Groovy&#8217;s method handling.
In Groovy we work with three kinds of objects: POJO, POGO and Groovy Interceptors. Groovy allows metaprogramming for all types of objects but in a different manner.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>POJO - A regular Java object whose class can be written in Java or any other language for the JVM.</p>
</li>
<li>
<p>POGO - A Groovy object whose class is written in Groovy. It extends <code>java.lang.Object</code> and implements the <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/GroovyObject.html">groovy.lang.GroovyObject</a> interface by default.</p>
</li>
<li>
<p>Groovy Interceptor - A Groovy object that implements the <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/GroovyInterceptable.html">groovy.lang.GroovyInterceptable</a> interface and has method-interception capability which is discussed in the <a href="#_groovyinterceptable">GroovyInterceptable</a> section.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For every method call Groovy checks whether the object is a POJO or a POGO. For POJOs, Groovy fetches its <code>MetaClass</code> from the <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/MetaClassRegistry.html">groovy.lang.MetaClassRegistry</a> and delegates method invocation to it. For POGOs, Groovy takes more steps, as illustrated in the following figure:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="assets/img/GroovyInterceptions.png" alt="GroovyInterceptions">
</div>
<div class="title">Figure 1. Groovy interception mechanism</div>
</div>
<div class="sect2">
<h3 id="_groovyobject_interface"><a class="anchor" href="#_groovyobject_interface"></a>1.1. GroovyObject interface</h3>
<div class="paragraph">
<p><a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/GroovyObject.html">groovy.lang.GroovyObject</a> is the main interface in Groovy as the <code>Object</code> class is in Java. <code>GroovyObject</code> has a default implementation in the <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/GroovyObjectSupport.html">groovy.lang.GroovyObjectSupport</a> class and it is responsible to transfer invocation to the <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/MetaClass.html">groovy.lang.MetaClass</a> object. The <code>GroovyObject</code> source looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">package groovy.lang;

public interface GroovyObject {

    Object invokeMethod(String name, Object args);

    Object getProperty(String propertyName);

    void setProperty(String propertyName, Object newValue);

    MetaClass getMetaClass();

    void setMetaClass(MetaClass metaClass);
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_invokemethod"><a class="anchor" href="#_invokemethod"></a>1.1.1. invokeMethod</h4>
<div class="paragraph">
<p>This method is primarily intended to be used in conjunction with the <a href="#_groovyinterceptable">GroovyInterceptable</a>
interface or an object&#8217;s <code>MetaClass</code> where it will intercept all method calls.</p>
</div>
<div class="paragraph">
<p>It is also invoked when the method called is not present on a Groovy object. Here is a simple example using an
overridden <code>invokeMethod()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SomeGroovyClass {

    def invokeMethod(String name, Object args) {
        return "called invokeMethod $name $args"
    }

    def test() {
        return 'method exists'
    }
}

def someGroovyClass = new SomeGroovyClass()

assert someGroovyClass.test() == 'method exists'
assert someGroovyClass.someMethod() == 'called invokeMethod someMethod []'</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, the use of <code>invokeMethod</code> to intercept missing methods is discouraged.  In cases where the intent is to only
intercept method calls in the case of a failed method dispatch use <a href="#_methodmissing">methodMissing</a>
instead.</p>
</div>
</div>
<div class="sect3">
<h4 id="_get_setproperty"><a class="anchor" href="#_get_setproperty"></a>1.1.2. get/setProperty</h4>
<div class="paragraph">
<p>Every read access to a property can be intercepted by overriding the <code>getProperty()</code> method of the current object.
Here is a simple example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SomeGroovyClass {

    def property1 = 'ha'
    def field2 = 'ho'
    def field4 = 'hu'

    def getField1() {
        return 'getHa'
    }

    def getProperty(String name) {
        if (name != 'field3')
            return metaClass.getProperty(this, name) <i class="conum" data-value="1"></i><b>(1)</b>
        else
            return 'field3'
    }
}

def someGroovyClass = new SomeGroovyClass()

assert someGroovyClass.field1 == 'getHa'
assert someGroovyClass.field2 == 'ho'
assert someGroovyClass.field3 == 'field3'
assert someGroovyClass.field4 == 'hu'</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Forwards the request to the getter for all properties except <code>field3</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can intercept write access to properties by overriding the <code>setProperty()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class POGO {

    String property

    void setProperty(String name, Object value) {
        this.@"$name" = 'overridden'
    }
}

def pogo = new POGO()
pogo.property = 'a'

assert pogo.property == 'overridden'</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_get_setmetaclass"><a class="anchor" href="#_get_setmetaclass"></a>1.1.3. get/setMetaClass</h4>
<div class="paragraph">
<p>You can access an object&#8217;s <code>metaClass</code> or set your own <code>MetaClass</code> implementation for changing the default interception mechanism. For example, you can write your own implementation of the <code>MetaClass</code> interface and assign it to objects in order to change the interception mechanism:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// getMetaclass
someObject.metaClass

// setMetaClass
someObject.metaClass = new OwnMetaClassImplementation()</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can find an additional example in the <a href="#_groovyinterceptable">GroovyInterceptable</a> topic.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_get_setattribute"><a class="anchor" href="#_get_setattribute"></a>1.2. get/setAttribute</h3>
<div class="paragraph">
<p>This functionality is related to the <code>MetaClass</code> implementation. In the default implementation you can access fields without invoking their getters and setters. The examples below demonstrates this approach:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SomeGroovyClass {

    def field1 = 'ha'
    def field2 = 'ho'

    def getField1() {
        return 'getHa'
    }
}

def someGroovyClass = new SomeGroovyClass()

assert someGroovyClass.metaClass.getAttribute(someGroovyClass, 'field1') == 'ha'
assert someGroovyClass.metaClass.getAttribute(someGroovyClass, 'field2') == 'ho'</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class POGO {

    private String field
    String property1

    void setProperty1(String property1) {
        this.property1 = "setProperty1"
    }
}

def pogo = new POGO()
pogo.metaClass.setAttribute(pogo, 'field', 'ha')
pogo.metaClass.setAttribute(pogo, 'property1', 'ho')

assert pogo.field == 'ha'
assert pogo.property1 == 'ho'</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_methodmissing"><a class="anchor" href="#_methodmissing"></a>1.3. methodMissing</h3>
<div class="paragraph">
<p>Groovy supports the concept of <code>methodMissing</code>. This method differs from <code>invokeMethod</code> in that it
is only invoked in the case of a failed method dispatch when no method can be found for the given name and/or the
given arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Foo {

   def methodMissing(String name, def args) {
        return "this is me"
   }
}

assert new Foo().someUnknownMethod(42l) == 'this is me'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Typically when using <code>methodMissing</code> it is possible to cache the result for the next time the same method is called.</p>
</div>
<div class="paragraph">
<p>For example, consider dynamic finders in GORM. These are implemented in terms of <code>methodMissing</code>. The code resembles
something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class GORM {

   def dynamicMethods = [...] // an array of dynamic methods that use regex

   def methodMissing(String name, args) {
       def method = dynamicMethods.find { it.match(name) }
       if(method) {
          GORM.metaClass."$name" = { Object[] varArgs -&gt;
             method.invoke(delegate, name, varArgs)
          }
          return method.invoke(delegate,name, args)
       }
       else throw new MissingMethodException(name, delegate, args)
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how, if we find a method to invoke, we then dynamically register a new method on the fly using <a href="#metaprogramming_emc">ExpandoMetaClass</a>.
This is so that the next time the same method is called it is more efficient. This way of using <code>methodMissing</code> does not have
the overhead of <code>invokeMethod</code> <em>and</em> is not expensive from the second call on.</p>
</div>
</div>
<div class="sect2">
<h3 id="_propertymissing"><a class="anchor" href="#_propertymissing"></a>1.4. propertyMissing</h3>
<div class="paragraph">
<p>Groovy supports the concept of <code>propertyMissing</code> for intercepting otherwise failing property resolution attempts. In the
case of a getter method, <code>propertyMissing</code> takes a single <code>String</code> argument containing the property name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Foo {
   def propertyMissing(String name) { name }
}

assert new Foo().boo == 'boo'</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>propertyMissing(String)</code> method is only called when no getter method for the given property can be found by the Groovy
runtime.</p>
</div>
<div class="paragraph">
<p>For setter methods a second <code>propertyMissing</code> definition can be added that takes an additional value argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Foo {
   def storage = [:]
   def propertyMissing(String name, value) { storage[name] = value }
   def propertyMissing(String name) { storage[name] }
}

def f = new Foo()
f.foo = "bar"

assert f.foo == "bar"</code></pre>
</div>
</div>
<div class="paragraph">
<p>As with <code>methodMissing</code> it is best practice to dynamically register new properties at runtime to improve the overall lookup
performance.</p>
</div>
</div>
<div class="sect2">
<h3 id="_static_methodmissing"><a class="anchor" href="#_static_methodmissing"></a>1.5. static methodMissing</h3>
<div class="paragraph">
<p>Static variant of <code>methodMissing</code> method can be added via the <a href="#metaprogramming_emc">ExpandoMetaClass</a>
or can be implemented at the class level with <code>$static_methodMissing</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Foo {
    static def $static_methodMissing(String name, Object args) {
        return "Missing static method name is $name"
    }
}

assert Foo.bar() == 'Missing static method name is bar'</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_static_propertymissing"><a class="anchor" href="#_static_propertymissing"></a>1.6. static propertyMissing</h3>
<div class="paragraph">
<p>Static variant of <code>propertyMissing</code> method can be added via the <a href="#metaprogramming_emc">ExpandoMetaClass</a>
or can be implemented at the class level with <code>$static_propertyMissing</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Foo {
    static def $static_propertyMissing(String name) {
        return "Missing static property name is $name"
    }
}

assert Foo.foobar == 'Missing static property name is foobar'</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_groovyinterceptable"><a class="anchor" href="#_groovyinterceptable"></a>1.7. GroovyInterceptable</h3>
<div class="paragraph">
<p>The <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/GroovyInterceptable.html">groovy.lang.GroovyInterceptable</a> interface is marker interface that extends <code>GroovyObject</code> and is used to notify the Groovy runtime that all methods should be intercepted through the method dispatcher mechanism of the Groovy runtime.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">package groovy.lang;

public interface GroovyInterceptable extends GroovyObject {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When a Groovy object implements the <code>GroovyInterceptable</code> interface, its <code>invokeMethod()</code> is called for any method calls. Below you can see a simple example of an object of this type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Interception implements GroovyInterceptable {

    def definedMethod() { }

    def invokeMethod(String name, Object args) {
        'invokedMethod'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next piece of code is a test which shows that both calls to existing and non-existing methods will return the same value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class InterceptableTest extends GroovyTestCase {

    void testCheckInterception() {
        def interception = new Interception()

        assert interception.definedMethod() == 'invokedMethod'
        assert interception.someMethod() == 'invokedMethod'
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We cannot use default groovy methods like <code>println</code> because these methods are injected into all Groovy objects so they will be intercepted too.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If we want to intercept all method calls but do not want to implement the <code>GroovyInterceptable</code> interface we can implement <code>invokeMethod()</code> on an object&#8217;s <code>MetaClass</code>.
This approach works for both POGOs and POJOs, as shown by this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class InterceptionThroughMetaClassTest extends GroovyTestCase {

    void testPOJOMetaClassInterception() {
        String invoking = 'ha'
        invoking.metaClass.invokeMethod = { String name, Object args -&gt;
            'invoked'
        }

        assert invoking.length() == 'invoked'
        assert invoking.someMethod() == 'invoked'
    }

    void testPOGOMetaClassInterception() {
        Entity entity = new Entity('Hello')
        entity.metaClass.invokeMethod = { String name, Object args -&gt;
            'invoked'
        }

        assert entity.build(new Object()) == 'invoked'
        assert entity.someMethod() == 'invoked'
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Additional information about <code>MetaClass</code> can be found in the <a href="#_metaclasses">MetaClasses</a> section.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="categories"><a class="anchor" href="#categories"></a>1.8. Categories</h3>
<div class="paragraph">
<p>There are situations where it is useful if a class <em>not</em> under control had additional methods. In order to enable this
capability, Groovy implements a feature borrowed from Objective-C, called <em>Categories</em>.</p>
</div>
<div class="paragraph">
<p>Categories are implemented with so-called <em>category classes</em>. A category class is special in that it needs to meet certain
pre-defined rules for defining extension methods.</p>
</div>
<div class="paragraph">
<p>There are a few categories that are included in the system for adding functionality to classes that make them more
usable within the Groovy environment:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/time/TimeCategory.html">groovy.time.TimeCategory</a></p>
</li>
<li>
<p><a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/servlet/ServletCategory.html">groovy.servlet.ServletCategory</a></p>
</li>
<li>
<p><a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/xml/dom/DOMCategory.html">groovy.xml.dom.DOMCategory</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Category classes aren&#8217;t enabled by default. To use the methods defined in a category class it is necessary to apply
the scoped <code>use</code> method that is provided by the GDK and available from inside every Groovy object instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">use(TimeCategory)  {
    println 1.minute.from.now       <i class="conum" data-value="1"></i><b>(1)</b>
    println 10.hours.ago

    def someDate = new Date()       <i class="conum" data-value="2"></i><b>(2)</b>
    println someDate - 3.months
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>TimeCategory</code> adds methods to <code>Integer</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>TimeCategory</code> adds methods to <code>Date</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>use</code> method takes the category class as its first parameter and a closure code block as second parameter. Inside the
<code>Closure</code> access to the category methods is available. As can be seen in the example above even JDK classes
like <code>java.lang.Integer</code> or <code>java.util.Date</code> can be enriched with user-defined methods.</p>
</div>
<div class="paragraph">
<p>A category needs not to be directly exposed to the user code, the following will also do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class JPACategory{
  // Let's enhance JPA EntityManager without getting into the JSR committee
  static void persistAll(EntityManager em , Object[] entities) { //add an interface to save all
    entities?.each { em.persist(it) }
  }
}

def transactionContext = {
  EntityManager em, Closure c -&gt;
  def tx = em.transaction
  try {
    tx.begin()
    use(JPACategory) {
      c()
    }
    tx.commit()
  } catch (e) {
    tx.rollback()
  } finally {
    //cleanup your resource here
  }
}

// user code, they always forget to close resource in exception, some even forget to commit, let's not rely on them.
EntityManager em; //probably injected
transactionContext (em) {
 em.persistAll(obj1, obj2, obj3)
 // let's do some logics here to make the example sensible
 em.persistAll(obj2, obj4, obj6)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we have a look at the <code>groovy.time.TimeCategory</code> class we see that the extension methods are all declared as <code>static</code>
methods. In fact, this is one of the requirements that must be met by category classes for its methods to be successfully added to
a class inside the <code>use</code> code block:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public class TimeCategory {

    public static Date plus(final Date date, final BaseDuration duration) {
        return duration.plus(date);
    }

    public static Date minus(final Date date, final BaseDuration duration) {
        final Calendar cal = Calendar.getInstance();

        cal.setTime(date);
        cal.add(Calendar.YEAR, -duration.getYears());
        cal.add(Calendar.MONTH, -duration.getMonths());
        cal.add(Calendar.DAY_OF_YEAR, -duration.getDays());
        cal.add(Calendar.HOUR_OF_DAY, -duration.getHours());
        cal.add(Calendar.MINUTE, -duration.getMinutes());
        cal.add(Calendar.SECOND, -duration.getSeconds());
        cal.add(Calendar.MILLISECOND, -duration.getMillis());

        return cal.getTime();
    }

    // ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another requirement is the first argument of the static method must define the type the method is attached to once being activated. The
other arguments are the normal arguments the method will take as parameters.</p>
</div>
<div class="paragraph">
<p>Because of the parameter and static method convention, category method definitions may be a bit less intuitive than
normal method definitions. As an alternative Groovy comes with a <code>@Category</code> annotation that transforms annotated classes
into category classes at compile-time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Distance {
    def number
    String toString() { "${number}m" }
}

@Category(Number)
class NumberCategory {
    Distance getMeters() {
        new Distance(number: this)
    }
}

use (NumberCategory)  {
    assert 42.meters.toString() == '42m'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Applying the <code>@Category</code> annotation has the advantage of being able to use instance methods without the target type as a
first parameter. The target type class is given as an argument to the annotation instead.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is a distinct section on <code>@Category</code> in the <a href="#xform-Category">compile-time metaprogramming section</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_metaclasses"><a class="anchor" href="#_metaclasses"></a>1.9. Metaclasses</h3>
<div class="paragraph">
<p>As explained earlier, Metaclasses play a central role in method resolution.
For every method invocation from groovy code, Groovy will find the <code>MetaClass</code> for the given object
and delegate the method resolution to the metaclass via
<a href="https://docs.groovy-lang.org/3.0.3/html/gapi/groovy/lang/MetaClass.html#invokeMethod(java.lang.Class, java.lang.Object, java.lang.String, java.lang.Object, boolean, boolean)">MetaClass#invokeMethod</a>
which should not be confused with
<a href="https://docs.groovy-lang.org/3.0.3/html/gapi/groovy/lang/GroovyObject.html#invokeMethod(java.lang.String, java.lang.Object)">GroovyObject#invokeMethod</a>
which happens to be a method that the metaclass may eventually call.</p>
</div>
<div class="sect3">
<h4 id="_the_default_metaclass_code_metaclassimpl_code"><a class="anchor" href="#_the_default_metaclass_code_metaclassimpl_code"></a>1.9.1. The default metaclass <code>MetaClassImpl</code></h4>
<div class="paragraph">
<p>By default, objects get an instance of <code>MetaClassImpl</code> that implements the default method lookup.
This method lookup includes looking up of the method in the object class ("regular" method) but also if no
method is found this way it will resort to calling <code>methodMissing</code> and ultimately
<a href="https://docs.groovy-lang.org/3.0.3/html/gapi/groovy/lang/GroovyObject.html#invokeMethod(java.lang.String, java.lang.Object)">GroovyObject#invokeMethod</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Foo {}

def f = new Foo()

assert f.metaClass =~ /MetaClassImpl/</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_custom_metaclasses"><a class="anchor" href="#_custom_metaclasses"></a>1.9.2. Custom metaclasses</h4>
<div class="paragraph">
<p>You can change the metaclass of any object or class and replace with a custom implementation of the <code>MetaClass</code> <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/MetaClass.html">interface</a>. Usually you will want to subclass one of the existing metaclasses <code>MetaClassImpl</code>, <code>DelegatingMetaClass</code>, <code>ExpandoMetaClass</code>, <code>ProxyMetaClass</code>, etc. otherwise you will need to implement the complete method lookup logic. Before using a new metaclass instance you should call  <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/groovy/lang/MetaClass.html#initialize()">groovy.lang.MetaClass#initialize()</a> otherwise the metaclass may or may not behave as expected.</p>
</div>
<div class="sect4">
<h5 id="_delegating_metaclass"><a class="anchor" href="#_delegating_metaclass"></a>Delegating metaclass</h5>
<div class="paragraph">
<p>If you only need to decorate an existing metaclass the <code>DelegatingMetaClass</code> simplifies that use case. The old metaclass implementation is still accessible via <code>super</code> making easy to apply pretransformations to the inputs, routing to other methods and postprocess the outputs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Foo { def bar() { "bar" } }

class MyFooMetaClass extends DelegatingMetaClass {
  MyFooMetaClass(MetaClass metaClass) { super(metaClass) }
  MyFooMetaClass(Class theClass) { super(theClass) }

  Object invokeMethod(Object object, String methodName, Object[] args) {
     def result = super.invokeMethod(object,methodName.toLowerCase(), args)
     result.toUpperCase();
  }
}


def mc =  new MyFooMetaClass(Foo.metaClass)
mc.initialize()

Foo.metaClass = mc
def f = new Foo()

assert f.BAR() == "BAR" // the new metaclass routes .BAR() to .bar() and uppercases the result</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_magic_package"><a class="anchor" href="#_magic_package"></a>Magic package</h5>
<div class="paragraph">
<p>It is possible to change the metaclass at startup time by giving the metaclass a specially crafted (magic) class name  and package name. In order to change the metaclass for <code>java.lang.Integer</code> it&#8217;s enough to put a class <code>groovy.runtime.metaclass.java.lang.IntegerMetaClass</code> in the classpath. This is useful, for example,  when working with frameworks if you want to do metaclass changes before your code is executed by the framework. The general form of the magic package is <code>groovy.runtime.metaclass.[package].[class]MetaClass</code>. In the example below the <code>[package]</code> is <code>java.lang</code> and the <code>[class]</code> is <code>Integer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// file: IntegerMetaClass.groovy
package groovy.runtime.metaclass.java.lang;

class IntegerMetaClass extends DelegatingMetaClass {
  IntegerMetaClass(MetaClass metaClass) { super(metaClass) }
  IntegerMetaClass(Class theClass) { super(theClass) }
  Object invokeMethod(Object object, String name, Object[] args) {
    if (name =~ /isBiggerThan/) {
      def other = name.split(/isBiggerThan/)[1].toInteger()
      object &gt; other
    } else {
      return super.invokeMethod(object,name, args);
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By compiling the above file with <code>groovyc IntegerMetaClass.groovy</code> a <code>./groovy/runtime/metaclass/java/lang/IntegerMetaClass.class</code> will be generated. The example below will use this new metaclass:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">// File testInteger.groovy
def i = 10

assert i.isBiggerThan5()
assert !i.isBiggerThan15()

println i.isBiggerThan5()</code></pre>
</div>
</div>
<div class="paragraph">
<p>By running that file with <code>groovy -cp . testInteger.groovy</code> the <code>IntegerMetaClass</code> will be in the classpath and therefore it will become the metaclass for <code>java.lang.Integer</code> intercepting the method calls to <code>isBiggerThan*()</code> methods.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_per_instance_metaclass"><a class="anchor" href="#_per_instance_metaclass"></a>1.9.3. Per instance metaclass</h4>
<div class="paragraph">
<p>You can change the metaclass of individual objects separately, so it&#8217;s possible to have multiple object of the same class with different metaclasses.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Foo { def bar() { "bar" }}

class FooMetaClass extends DelegatingMetaClass {
  FooMetaClass(MetaClass metaClass) { super(metaClass) }
  Object invokeMethod(Object object, String name, Object[] args) {
      super.invokeMethod(object,name,args).toUpperCase()
  }
}

def f1 = new Foo()
def f2 = new Foo()
f2.metaClass = new FooMetaClass(f2.metaClass)

assert f1.bar() == "bar"
assert f2.bar() == "BAR"
assert f1.metaClass =~ /MetaClassImpl/
assert f2.metaClass =~ /FooMetaClass/
assert f1.class.toString() == "class Foo"
assert f2.class.toString() == "class Foo"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="metaprogramming_emc"><a class="anchor" href="#metaprogramming_emc"></a>1.9.4. ExpandoMetaClass</h4>
<div class="paragraph">
<p>Groovy comes with a special <code>MetaClass</code> the so-called <code>ExpandoMetaClass</code>. It is special in that it allows for dynamically
adding or changing methods, constructors, properties and even static methods by using a neat closure syntax.</p>
</div>
<div class="paragraph">
<p>Applying those modifications can be especially useful in mocking or stubbing scenarios as shown in the <a href="core-testing-guide.html#testing_guide_emc">Testing Guide</a>.</p>
</div>
<div class="paragraph">
<p>Every <code>java.lang.Class</code> is supplied by Groovy with a special <code>metaClass</code> property that will give you a reference to an
<code>ExpandoMetaClass</code> instance. This instance can then be used to add methods or change the behaviour of already existing
ones.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By default <code>ExpandoMetaClass</code> doesn&#8217;t do inheritance. To enable this you must call <code>ExpandoMetaClass#enableGlobally()</code>
before your app starts such as in the main method or servlet bootstrap.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following sections go into detail on how <code>ExpandoMetaClass</code> can be used in various scenarios.</p>
</div>
<div class="sect4">
<h5 id="_methods"><a class="anchor" href="#_methods"></a>Methods</h5>
<div class="paragraph">
<p>Once the <code>ExpandoMetaClass</code> is accessed by calling the <code>metaClass</code> property, methods can added by using either the left shift
<code>&lt;&lt;</code> or the <code>=</code> operator.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Note that the left shift operator is used to <em>append</em> a new method. If a public method with the same name and
parameter types is declared by the class or interface, including those inherited from superclasses and superinterfaces
but excluding those added to the <code>metaClass</code> at runtime, an exception will be thrown. If you want to <em>replace</em> a
method declared by the class or interface you can use the <code>=</code> operator.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The operators are applied on a non-existent property of <code>metaClass</code> passing an instance of a <code>Closure</code> code block.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Book {
   String title
}

Book.metaClass.titleInUpperCase &lt;&lt; {-&gt; title.toUpperCase() }

def b = new Book(title:"The Stand")

assert "THE STAND" == b.titleInUpperCase()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above shows how a new method can be added to a class by accessing the <code>metaClass</code> property and using the <code>&lt;&lt;</code> or
 <code>=</code> operator to assign a <code>Closure</code> code block. The <code>Closure</code> parameters are interpreted as method parameters. Parameterless methods
 can be added by using the <code>{&#8594; &#8230;&#8203;}</code> syntax.</p>
</div>
</div>
<div class="sect4">
<h5 id="_properties"><a class="anchor" href="#_properties"></a>Properties</h5>
<div class="paragraph">
<p><code>ExpandoMetaClass</code> supports two mechanisms for adding or overriding properties.</p>
</div>
<div class="paragraph">
<p>Firstly, it has support for declaring a <em>mutable property</em> by simply assigning a value to a property of <code>metaClass</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Book {
   String title
}

Book.metaClass.author = "Stephen King"
def b = new Book()

assert "Stephen King" == b.author</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another way is to add getter and/or setter methods by using the standard mechanisms for adding instance methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Book {
  String title
}
Book.metaClass.getAuthor &lt;&lt; {-&gt; "Stephen King" }

def b = new Book()

assert "Stephen King" == b.author</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the source code example above the property is dictated by the closure and is a read-only property. It is feasible to add
an equivalent setter method but then the property value needs to be stored for later usage. This could be done as
shown in the following example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Book {
  String title
}

def properties = Collections.synchronizedMap([:])

Book.metaClass.setAuthor = { String value -&gt;
   properties[System.identityHashCode(delegate) + "author"] = value
}
Book.metaClass.getAuthor = {-&gt;
   properties[System.identityHashCode(delegate) + "author"]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is not the only technique however. For example in a servlet container one way might be to store the values in
the currently executing request as request attributes (as is done in some cases in Grails).</p>
</div>
</div>
<div class="sect4">
<h5 id="_constructors"><a class="anchor" href="#_constructors"></a>Constructors</h5>
<div class="paragraph">
<p>Constructors can be added by using a special <code>constructor</code> property. Either the <code>&lt;&lt;</code> or <code>=</code> operator can be used
to assign a <code>Closure</code> code block. The <code>Closure</code> arguments will become the constructor arguments when the code is
executed at runtime.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Book {
    String title
}
Book.metaClass.constructor &lt;&lt; { String title -&gt; new Book(title:title) }

def book = new Book('Groovy in Action - 2nd Edition')
assert book.title == 'Groovy in Action - 2nd Edition'</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Be careful when adding constructors however, as it is very easy to get into stack overflow troubles.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_static_methods"><a class="anchor" href="#_static_methods"></a>Static Methods</h5>
<div class="paragraph">
<p>Static methods can be added using the same technique as instance methods with the addition of the <code>static</code> qualifier
before the method name.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Book {
   String title
}

Book.metaClass.static.create &lt;&lt; { String title -&gt; new Book(title:title) }

def b = Book.create("The Stand")</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_borrowing_methods"><a class="anchor" href="#_borrowing_methods"></a>Borrowing Methods</h5>
<div class="paragraph">
<p>With <code>ExpandoMetaClass</code> it is possible to use Groovy&#8217;s method pointer syntax to borrow methods from other classes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
}
class MortgageLender {
   def borrowMoney() {
      "buy house"
   }
}

def lender = new MortgageLender()

Person.metaClass.buyHouse = lender.&amp;borrowMoney

def p = new Person()

assert "buy house" == p.buyHouse()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_dynamic_method_names"><a class="anchor" href="#_dynamic_method_names"></a>Dynamic Method Names</h5>
<div class="paragraph">
<p>Since Groovy allows you to use Strings as property names this in turns allows you to dynamically create method and
property names at runtime. To create a method with a dynamic name simply use the language feature of reference property
names as strings.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
   String name = "Fred"
}

def methodName = "Bob"

Person.metaClass."changeNameTo${methodName}" = {-&gt; delegate.name = "Bob" }

def p = new Person()

assert "Fred" == p.name

p.changeNameToBob()

assert "Bob" == p.name</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same concept can be applied to static methods and properties.</p>
</div>
<div class="paragraph">
<p>One application of dynamic method names can be found in the Grails web application framework. The concept of "dynamic
codecs" is implemented by using dynamic method names.</p>
</div>
<div class="listingblock">
<div class="title"><code>HTMLCodec</code> Class</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class HTMLCodec {
    static encode = { theTarget -&gt;
        HtmlUtils.htmlEscape(theTarget.toString())
    }

    static decode = { theTarget -&gt;
    	HtmlUtils.htmlUnescape(theTarget.toString())
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above shows a codec implementation. Grails comes with various codec implementations each defined in a single class.
At runtime there will be multiple codec classes in the application classpath. At application startup the framework adds
a <code>encodeXXX</code> and a <code>decodeXXX</code> method to certain meta-classes where <code>XXX</code> is the first part of the codec class name (e.g.
<code>encodeHTML</code>). This mechanism is in the following shown in some Groovy pseudo-code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def codecs = classes.findAll { it.name.endsWith('Codec') }

codecs.each { codec -&gt;
    Object.metaClass."encodeAs${codec.name-'Codec'}" = { codec.newInstance().encode(delegate) }
    Object.metaClass."decodeFrom${codec.name-'Codec'}" = { codec.newInstance().decode(delegate) }
}


def html = '&lt;html&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;'

assert '&lt;html&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;' == html.encodeAsHTML()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_runtime_discovery"><a class="anchor" href="#_runtime_discovery"></a>Runtime Discovery</h5>
<div class="paragraph">
<p>At runtime it is often useful to know what other methods or properties exist at the time the method is executed. <code>ExpandoMetaClass</code>
provides the following methods as of this writing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getMetaMethod</code></p>
</li>
<li>
<p><code>hasMetaMethod</code></p>
</li>
<li>
<p><code>getMetaProperty</code></p>
</li>
<li>
<p><code>hasMetaProperty</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Why can&#8217;t you just use reflection? Well because Groovy is different, it has the methods that are "real" methods and
methods that are available only at runtime. These are sometimes (but not always) represented as MetaMethods. The
MetaMethods tell you what methods are available at runtime, thus your code can adapt.</p>
</div>
<div class="paragraph">
<p>This is of particular use when overriding <code>invokeMethod</code>, <code>getProperty</code> and/or <code>setProperty</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_groovyobject_methods"><a class="anchor" href="#_groovyobject_methods"></a>GroovyObject Methods</h5>
<div class="paragraph">
<p>Another feature of <code>ExpandoMetaClass</code> is that it allows to override the methods <code>invokeMethod</code>, <code>getProperty</code> and
<code>setProperty</code>, all of them can be found in the <code>groovy.lang.GroovyObject</code> class.</p>
</div>
<div class="paragraph">
<p>The following example shows how to override <code>invokeMethod</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Stuff {
   def invokeMe() { "foo" }
}

Stuff.metaClass.invokeMethod = { String name, args -&gt;
   def metaMethod = Stuff.metaClass.getMetaMethod(name, args)
   def result
   if(metaMethod) result = metaMethod.invoke(delegate,args)
   else {
      result = "bar"
   }
   result
}

def stf = new Stuff()

assert "foo" == stf.invokeMe()
assert "bar" == stf.doStuff()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first step in the <code>Closure</code> code is to lookup the <code>MetaMethod</code> for the given name and arguments. If the method
can be found everything is fine and it is delegated to. If not, a dummy value is returned.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A <code>MetaMethod</code> is a method that is known to exist on the <code>MetaClass</code> whether added at runtime or at compile-time.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The same logic can be used to override <code>setProperty</code> or <code>getProperty</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
   String name = "Fred"
}

Person.metaClass.getProperty = { String name -&gt;
   def metaProperty = Person.metaClass.getMetaProperty(name)
   def result
   if(metaProperty) result = metaProperty.getProperty(delegate)
   else {
      result = "Flintstone"
   }
   result
}

def p = new Person()

assert "Fred" == p.name
assert "Flintstone" == p.other</code></pre>
</div>
</div>
<div class="paragraph">
<p>The important thing to note here is that instead of a <code>MetaMethod</code> a <code>MetaProperty</code> instance is looked up. If that exists
the <code>getProperty</code> method of the <code>MetaProperty</code> is called, passing the delegate.</p>
</div>
</div>
<div class="sect4">
<h5 id="_overriding_static_invokemethod"><a class="anchor" href="#_overriding_static_invokemethod"></a>Overriding Static invokeMethod</h5>
<div class="paragraph">
<p><code>ExpandoMetaClass</code> even allows for overriding static method with a special <code>invokeMethod</code> syntax.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Stuff {
   static invokeMe() { "foo" }
}

Stuff.metaClass.'static'.invokeMethod = { String name, args -&gt;
   def metaMethod = Stuff.metaClass.getStaticMetaMethod(name, args)
   def result
   if(metaMethod) result = metaMethod.invoke(delegate,args)
   else {
      result = "bar"
   }
   result
}

assert "foo" == Stuff.invokeMe()
assert "bar" == Stuff.doStuff()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The logic that is used for overriding the static method is the same as we&#8217;ve seen before for overriding instance methods. The
only difference is the access to the <code>metaClass.static</code> property and the call to <code>getStaticMethodName</code> for retrieving
the static <code>MetaMethod</code> instance.</p>
</div>
</div>
<div class="sect4">
<h5 id="_extending_interfaces"><a class="anchor" href="#_extending_interfaces"></a>Extending Interfaces</h5>
<div class="paragraph">
<p>It is possible to add methods onto interfaces with <code>ExpandoMetaClass</code>. To do this however, it <strong>must</strong> be enabled
globally using the <code>ExpandoMetaClass.enableGlobally()</code> method before application start-up.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">List.metaClass.sizeDoubled = {-&gt; delegate.size() * 2 }

def list = []

list &lt;&lt; 1
list &lt;&lt; 2

assert 4 == list.sizeDoubled()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_extension_modules"><a class="anchor" href="#_extension_modules"></a>1.10. Extension modules</h3>
<div class="sect3">
<h4 id="_extending_existing_classes"><a class="anchor" href="#_extending_existing_classes"></a>1.10.1. Extending existing classes</h4>
<div class="paragraph">
<p>An extension module allows you to add new methods to existing classes, including classes which are precompiled, like
classes from the JDK. Those new methods, unlike those defined through a metaclass or using a category, are available
globally. For example, when you write:</p>
</div>
<div class="listingblock">
<div class="title">Standard extension method</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def file = new File(...)
def contents = file.getText('utf-8')</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>getText</code> method doesn’t exist on the <code>File</code> class. However, Groovy knows it because it is defined in a special
class, <code>ResourceGroovyMethods</code>:</p>
</div>
<div class="listingblock">
<div class="title">ResourceGroovyMethods.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public static String getText(File file, String charset) throws IOException {
 return IOGroovyMethods.getText(newReader(file, charset));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may notice that the extension method is defined using a static method in a helper class (where various extension
methods are defined). The first argument of the <code>getText</code> method corresponds to the receiver, while additional parameters
correspond to the arguments of the extension method. So here, we are defining a method called <em>getText</em> on
the <code>File</code> class (because the first argument is of type <code>File</code>), which takes a single argument as a parameter (the encoding <code>String</code>).</p>
</div>
<div class="paragraph">
<p>The process of creating an extension module is simple:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>write an extension class like above</p>
</li>
<li>
<p>write a module descriptor file</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Then you have to make the extension module visible to Groovy, which is as simple as having the extension module classes
and descriptor available on classpath. This means that you have the choice:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>either provide the classes and module descriptor directly on classpath</p>
</li>
<li>
<p>or bundle your extension module into a jar for reusability</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An extension module may add two kind of methods to a class:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>instance methods (to be called on an instance of a class)</p>
</li>
<li>
<p>static methods (to be called on the class itself)</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_instance_methods"><a class="anchor" href="#_instance_methods"></a>1.10.2. Instance methods</h4>
<div class="paragraph">
<p>To add an instance method to an existing class, you need to create an extension class. For example, let&#8217;s say you
want to add a <code>maxRetries</code> method on <code>Integer</code> which accepts a closure and executes it at most <em>n</em> times until no
exception is thrown. To do that, you only need to write the following:</p>
</div>
<div class="listingblock">
<div class="title">MaxRetriesExtension.groovy</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MaxRetriesExtension {                                     <i class="conum" data-value="1"></i><b>(1)</b>
    static void maxRetries(Integer self, Closure code) {        <i class="conum" data-value="2"></i><b>(2)</b>
        assert self &gt;= 0
        int retries = self
        Throwable e = null
        while (retries &gt; 0) {
            try {
                code.call()
                break
            } catch (Throwable err) {
                e = err
                retries--
            }
        }
        if (retries == 0 &amp;&amp; e) {
            throw e
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The extension class</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>First argument of the static method corresponds to the receiver of the message, that is to say the extended instance</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Then, after <a href="#module-descriptor">having declared your extension class</a>, you can call it this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">int i=0
5.maxRetries {
    i++
}
assert i == 1
i=0
try {
    5.maxRetries {
        i++
        throw new RuntimeException("oops")
    }
} catch (RuntimeException e) {
    assert i == 5
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_static_methods_2"><a class="anchor" href="#_static_methods_2"></a>1.10.3. Static methods</h4>
<div class="paragraph">
<p>It is also possible to add static methods to a class. In that case, the static method needs to be defined in its <strong>own</strong>
file. Static and instance extension methods <strong>cannot</strong> be present in the same class.</p>
</div>
<div class="listingblock">
<div class="title">StaticStringExtension.groovy</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class StaticStringExtension {                                       <i class="conum" data-value="1"></i><b>(1)</b>
    static String greeting(String self) {                           <i class="conum" data-value="2"></i><b>(2)</b>
        'Hello, world!'
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The static extension class</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>First argument of the static method corresponds to the class being extended and is <strong>unused</strong></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In which case you can call it directly on the <code>String</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert String.greeting() == 'Hello, world!'</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="module-descriptor"><a class="anchor" href="#module-descriptor"></a>1.10.4. Module descriptor</h4>
<div class="paragraph">
<p>For Groovy to be able to load your extension methods, you must declare
your extension helper classes. You must create a file named
<code>org.codehaus.groovy.runtime.ExtensionModule</code> into the
<code>META-INF/groovy</code> directory:</p>
</div>
<div class="listingblock">
<div class="title">org.codehaus.groovy.runtime.ExtensionModule</div>
<div class="content">
<pre>moduleName=Test module for specifications
moduleVersion=1.0-test
extensionClasses=support.MaxRetriesExtension
staticExtensionClasses=support.StaticStringExtension</pre>
</div>
</div>
<div class="paragraph">
<p>The module descriptor requires 4 keys:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>moduleName</em> : the name of your module</p>
</li>
<li>
<p><em>moduleVersion</em>: the version of your module. Note that version number
is only used to check that you don’t load the same module in two
different versions.</p>
</li>
<li>
<p><em>extensionClasses</em>: the list of extension helper classes for instance
methods. You can provide several classes, given that they are comma
separated.</p>
</li>
<li>
<p><em>staticExtensionClasses</em>: the list of extension helper classes for
static methods. You can provide several classes, given that they are
comma separated.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that it is not required for a module to define both static helpers
and instance helpers, and that you may add several classes to a single
module. You can also extend different classes in a single module without
problem. It is even possible to use different classes in a single
extension class, but it is recommended to group extension methods into
classes by feature set.</p>
</div>
</div>
<div class="sect3">
<h4 id="_extension_modules_and_classpath"><a class="anchor" href="#_extension_modules_and_classpath"></a>1.10.5. Extension modules and classpath</h4>
<div class="paragraph">
<p>It&#8217;s worth noting that you can&#8217;t use an extension which is compiled at the same time as code using it. That means that
to use an extension, it <strong>has</strong> to be available on classpath, as compiled classes, before the code using it gets compiled.
Usually, this means that you can&#8217;t have the <em>test</em> classes in the same source unit as the extension class itself. Since
in general, test sources are separated from normal sources and executed in another step of the build, this is not an issue.</p>
</div>
</div>
<div class="sect3">
<h4 id="_compatibility_with_type_checking"><a class="anchor" href="#_compatibility_with_type_checking"></a>1.10.6. Compatibility with type checking</h4>
<div class="paragraph">
<p>Unlike categories, extension modules are compatible with type checking: if they are found on classpath, then the type
checker is aware of the extension methods and will not complain when you call them. It is also compatible with static
compilation.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compile_time_metaprogramming"><a class="anchor" href="#_compile_time_metaprogramming"></a>2. Compile-time metaprogramming</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Compile-time metaprogramming in Groovy allows code generation at compile-time. Those transformations are altering the
Abstract Syntax Tree (AST) of a program, which is why in Groovy we call it AST transformations. AST transformations
allow you to hook into the compilation process, modify the AST and continue the compilation process to generate regular
bytecode. Compared to runtime metaprogramming, this has the advantage of making the changes visible in the class file
itself (that is to say, in the bytecode). Making it visible in the bytecode is important for example if you want the
transformations to be part of the class contract (implementing interfaces, extending abstract classes, &#8230;&#8203;) or even
if you need your class to be callable from Java (or other JVM languages). For example, an AST transformation can add
methods to a class. If you do it with runtime metaprogramming, the new method would only be visible from Groovy. If you
do the same using compile-time metaprogramming, the method would be visible from Java too. Last but not least, performance
would likely be better with compile-time metaprogramming (because no initialization phase is required).</p>
</div>
<div class="paragraph">
<p>In this section, we will start with explaining the various compile-time transformations that are bundled with the Groovy
distribution. In a subsequent section, we will describe how you can <a href="#developing-ast-xforms">implement your own AST transformations</a>
and what are the disadvantages of this technique.</p>
</div>
<div class="sect2">
<h3 id="_available_ast_transformations"><a class="anchor" href="#_available_ast_transformations"></a>2.1. Available AST transformations</h3>
<div class="paragraph">
<p>Groovy comes with various AST transformations covering different needs: reducing boilerplate (code generation), implementing
design patterns (delegation, &#8230;&#8203;), logging, declarative concurrency, cloning, safer scripting, tweaking the compilation,
implementing Swing patterns, testing and eventually managing dependencies. If none of those AST transformations cover
your needs, you can still implement your own, as show in section <a href="#developing-ast-xforms">Developing your own AST transformations</a>.</p>
</div>
<div class="paragraph">
<p>AST transformations can be separated into two categories:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>global AST transformations are applied transparently, globally, as soon as they are found on compile classpath</p>
</li>
<li>
<p>local AST transformations are applied by annotating the source code with markers. Unlike global AST transformations,
local AST transformations may support parameters.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Groovy doesn&#8217;t ship with any global AST transformation, but you can find a list of local AST transformations
available for you to use in your code here:</p>
</div>
<div class="sect3">
<h4 id="_code_generation_transformations"><a class="anchor" href="#_code_generation_transformations"></a>2.1.1. Code generation transformations</h4>
<div class="paragraph">
<p>This category of transformation includes AST transformations which help removing boilerplate code. This is typically
code that you have to write but that does not carry any useful information. By autogenerating this boilerplate code,
the code you have to write is left clean and concise and the chance of introducing an error by getting such
boilerplate code incorrect is reduced.</p>
</div>
<div class="sect4">
<h5 id="xform-ToString"><a class="anchor" href="#xform-ToString"></a><code>@groovy.transform.ToString</code></h5>
<div class="paragraph">
<p>The <code>@ToString</code> AST transformation generates a human readable <code>toString</code> representation of the class. For example,
annotating the <code>Person</code> class like below will automatically generate the <code>toString</code> method for you:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.ToString

@ToString
class Person {
    String firstName
    String lastName
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this definition, then the following assertion passes, meaning that a <code>toString</code> method taking the field values from
the class and printing them out has been generated:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def p = new Person(firstName: 'Jack', lastName: 'Nicholson')
assert p.toString() == 'Person(Jack, Nicholson)'</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@ToString</code> annotation accepts several parameters which are summarized in the following table:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Default value</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">excludes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Empty list</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List of properties to exclude from toString</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString(excludes=['firstName'])
class Person {
    String firstName
    String lastName
}

def p = new Person(firstName: 'Jack', lastName: 'Nicholson')
assert p.toString() == 'Person(Nicholson)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Undefined marker list (indicates all fields)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List of fields to include in toString</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString(includes=['lastName'])
class Person {
    String firstName
    String lastName
}

def p = new Person(firstName: 'Jack', lastName: 'Nicholson')
assert p.toString() == 'Person(Nicholson)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeSuper</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should superclass be included in toString</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString
class Id { long id }

@ToString(includeSuper=true)
class Person extends Id {
    String firstName
    String lastName
}

def p = new Person(id:1, firstName: 'Jack', lastName: 'Nicholson')
assert p.toString() == 'Person(Jack, Nicholson, Id(1))'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeNames</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether to include names of properties in generated toString.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString(includeNames=true)
class Person {
    String firstName
    String lastName
}

def p = new Person(firstName: 'Jack', lastName: 'Nicholson')
assert p.toString() == 'Person(firstName:Jack, lastName:Nicholson)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeFields</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should fields be included in toString, in addition to properties</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString(includeFields=true)
class Person {
    String firstName
    String lastName
    private int age
    void test() {
       age = 42
    }
}

def p = new Person(firstName: 'Jack', lastName: 'Nicholson')
p.test()
assert p.toString() == 'Person(Jack, Nicholson, 42)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeSuperProperties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should super properties be included in toString</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name
}

@ToString(includeSuperProperties = true, includeNames = true)
class BandMember extends Person {
    String bandName
}

def bono = new BandMember(name:'Bono', bandName: 'U2').toString()

assert bono.toString() == 'BandMember(bandName:U2, name:Bono)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeSuperFields</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should visible super fields be included in toString</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    protected String name
}

@ToString(includeSuperFields = true, includeNames = true)
@MapConstructor(includeSuperFields = true)
class BandMember extends Person {
    String bandName
}

def bono = new BandMember(name:'Bono', bandName: 'U2').toString()

assert bono.toString() == 'BandMember(bandName:U2, name:Bono)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ignoreNulls</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should properties/fields with null value be displayed</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString(ignoreNulls=true)
class Person {
    String firstName
    String lastName
}

def p = new Person(firstName: 'Jack')
assert p.toString() == 'Person(Jack)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includePackage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Use fully qualified class name instead of simple name in toString</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString(includePackage=true)
class Person {
    String firstName
    String lastName
}

def p = new Person(firstName: 'Jack', lastName:'Nicholson')
assert p.toString() == 'acme.Person(Jack, Nicholson)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">allProperties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Include all JavaBean properties in toString</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString(includeNames=true)
class Person {
    String firstName
    String getLastName() { 'Nicholson' }
}

def p = new Person(firstName: 'Jack')
assert p.toString() == 'acme.Person(firstName:Jack, lastName:Nicholson)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cache</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cache the toString string. Should only be set to true if the class is immutable.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString(cache=true)
class Person {
    String firstName
    String lastName
}

def p = new Person(firstName: 'Jack', lastName:'Nicholson')
def s1 = p.toString()
def s2 = p.toString()
assert s1 == s2
assert s1 == 'Person(Jack, Nicholson)'
assert s1.is(s2) // same instance</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">allNames</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should fields and/or properties with internal names be included in the generated toString</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString(allNames=true)
class Person {
    String $firstName
}

def p = new Person($firstName: "Jack")
assert p.toString() == 'acme.Person(Jack)'</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="xform-EqualsAndHashCode"><a class="anchor" href="#xform-EqualsAndHashCode"></a><code>@groovy.transform.EqualsAndHashCode</code></h5>
<div class="paragraph">
<p>The <code>@EqualsAndHashCode</code> AST transformation aims at generating <code>equals</code> and <code>hashCode</code> methods for you. The generated
hashcode follows the best practices as described in <em>Effective Java</em> by <em>Josh Bloch</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.EqualsAndHashCode

@EqualsAndHashCode
class Person {
    String firstName
    String lastName
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
def p2 = new Person(firstName: 'Jack', lastName: 'Nicholson')

assert p1==p2
assert p1.hashCode() == p2.hashCode()</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are several options available to tweak the behavior of <code>@EqualsAndHashCode</code>:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Default value</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">excludes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Empty list</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List of properties to exclude from equals/hashCode</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.EqualsAndHashCode

@EqualsAndHashCode(excludes=['firstName'])
class Person {
    String firstName
    String lastName
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
def p2 = new Person(firstName: 'Bob', lastName: 'Nicholson')

assert p1==p2
assert p1.hashCode() == p2.hashCode()</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Undefined marker list (indicating all fields)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List of fields to include in equals/hashCode</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.EqualsAndHashCode

@EqualsAndHashCode(includes=['lastName'])
class Person {
    String firstName
    String lastName
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
def p2 = new Person(firstName: 'Bob', lastName: 'Nicholson')

assert p1==p2
assert p1.hashCode() == p2.hashCode()</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cache</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cache the hashCode computation. Should only be set to true if the class is immutable.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.EqualsAndHashCode
import groovy.transform.Immutable

@Immutable
class SlowHashCode {
    static final SLEEP_PERIOD = 500

    int hashCode() {
        sleep SLEEP_PERIOD
        127
    }
}

@EqualsAndHashCode(cache=true)
@Immutable
class Person {
    SlowHashCode slowHashCode = new SlowHashCode()
}

def p = new Person()
p.hashCode()

def start = System.currentTimeMillis()
p.hashCode()
assert System.currentTimeMillis() - start &lt; SlowHashCode.SLEEP_PERIOD</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">callSuper</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether to include super in equals and hashCode calculations</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.EqualsAndHashCode

@EqualsAndHashCode
class Living {
    String race
}

@EqualsAndHashCode(callSuper=true)
class Person extends Living {
    String firstName
    String lastName
}

def p1 = new Person(race:'Human', firstName: 'Jack', lastName: 'Nicholson')
def p2 = new Person(race: 'Human being', firstName: 'Jack', lastName: 'Nicholson')

assert p1!=p2
assert p1.hashCode() != p2.hashCode()</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeFields</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should fields be included in equals/hashCode, in addition to properties</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.EqualsAndHashCode

@EqualsAndHashCode(includeFields=true)
class Person {
    private String firstName

    Person(String firstName) {
        this.firstName = firstName
    }
}

def p1 = new Person('Jack')
def p2 = new Person('Jack')
def p3 = new Person('Bob')

assert p1 == p2
assert p1 != p3</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">useCanEqual</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should equals call canEqual helper method.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>See <a href="http://www.artima.com/lejava/articles/equality.html" class="bare">http://www.artima.com/lejava/articles/equality.html</a></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">allProperties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should JavaBean properties be included in equals and hashCode calculations</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@EqualsAndHashCode(allProperties=true, excludes='first, last')
class Person {
    String first, last
    String getInitials() { first[0] + last[0] }
}

def p1 = new Person(first: 'Jack', last: 'Smith')
def p2 = new Person(first: 'Jack', last: 'Spratt')
def p3 = new Person(first: 'Bob', last: 'Smith')

assert p1 == p2
assert p1.hashCode() == p2.hashCode()
assert p1 != p3
assert p1.hashCode() != p3.hashCode()</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">allNames</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should fields and/or properties with internal names be included in equals and hashCode calculations</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.EqualsAndHashCode

@EqualsAndHashCode(allNames=true)
class Person {
    String $firstName
}

def p1 = new Person($firstName: 'Jack')
def p2 = new Person($firstName: 'Bob')

assert p1 != p2
assert p1.hashCode() != p2.hashCode()</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="xform-TupleConstructor"><a class="anchor" href="#xform-TupleConstructor"></a><code>@groovy.transform.TupleConstructor</code></h5>
<div class="paragraph">
<p>The <code>@TupleConstructor</code> annotation aims at eliminating boilerplate code by generating constructors for you. A tuple
constructor is created having a parameter for each property (and possibly each field). Each parameter has a default value
(using the initial value of the property if present or otherwise Java&#8217;s default value according to the properties type).</p>
</div>
</div>
<div class="sect4">
<h5 id="_implementation_details"><a class="anchor" href="#_implementation_details"></a>Implementation Details</h5>
<div class="paragraph">
<p>Normally you don&#8217;t need to understand the imp[ementation details of the generated constructor(s); you just use them in the normal way.
However, if you want to add multiple constructors, understand Java integration options or meet requirements of some
dependency injection frameworks, then some details are useful.</p>
</div>
<div class="paragraph">
<p>As previously mentioned, the generated constructor has default values applied. In later compilation phases,
the Groovy compiler&#8217;s standard default value processing behavior is then applied.
The end result is that multiple constructors are placed within the bytecode of your class.
This provides a well understood semantics and is also useful for Java integration purposes. As an example, the
following code will generate 3 constructors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor

@TupleConstructor
class Person {
    String firstName
    String lastName
}

// traditional map-style constructor
def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
// generated tuple constructor
def p2 = new Person('Jack', 'Nicholson')
// generated tuple constructor with default value for second property
def p3 = new Person('Jack')</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first constructor is a no-arg constructor which allows the traditional map-style construction so long as
you don&#8217;t have final properties. Groovy calls the no-arg constructor and then the relevant setters under the covers.
It is worth noting that if the first property (or field) has type LinkedHashMap or if there is a single Map,
AbstractMap or HashMap property (or field), then the map-style named arguments won&#8217;t be available.</p>
</div>
<div class="paragraph">
<p>The other constructors are generated by taking the properties in the order they are defined. Groovy will generate as
many constructors as there are properties (or fields, depending on the options).</p>
</div>
<div class="paragraph">
<p>Setting the <code>defaults</code> attribute (see the available configuration options table) to <code>false</code>, disables the normal default values behavior which means:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Exactly one constructor will be produced</p>
</li>
<li>
<p>Attempting to use an initial value will produce an error</p>
</li>
<li>
<p>Map-style named arguments won&#8217;t be available</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This attribute is normally only used in situations where another Java framework is
expecting exactly one constructor, e.g. injection frameworks or JUnit parameterized runners.</p>
</div>
</div>
<div class="sect4">
<h5 id="_immutability_support"><a class="anchor" href="#_immutability_support"></a>Immutability support</h5>
<div class="paragraph">
<p>If the <code>@PropertyOptions</code> annotation is also found on the class with the <code>@TupleConstructor</code> annotation,
then the generated constructor may contain custom property handling logic.
The <code>propertyHandler</code> attribute on the <code>@PropertyOptions</code> annotation could for instance be set to
<code>ImmutablePropertyHandler</code> which will result in the addition of the necessary logic for immutable classes
(defensive copy in, cloning, etc.). This normally would happen automatically behind the scenes when you use
the <code>@Immutable</code> meta-annotation.
Some of the annotation attributes might not be supported by all property handlers.</p>
</div>
</div>
<div class="sect4">
<h5 id="_customization_options"><a class="anchor" href="#_customization_options"></a>Customization options</h5>
<div class="paragraph">
<p>The <code>@TupleConstructor</code> AST transformation accepts several annotation attributes:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Default value</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">excludes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Empty list</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List of properties to exclude from tuple constructor generation</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor

@TupleConstructor(excludes=['lastName'])
class Person {
    String firstName
    String lastName
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
def p2 = new Person('Jack')
try {
    // will fail because the second property is excluded
    def p3 = new Person('Jack', 'Nicholson')
} catch (e) {
    assert e.message.contains ('Could not find matching constructor')
}</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Undefined list (indicates all fields)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List of fields to include in tuple constructor generation</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor

@TupleConstructor(includes=['firstName'])
class Person {
    String firstName
    String lastName
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
def p2 = new Person('Jack')
try {
    // will fail because the second property is not included
    def p3 = new Person('Jack', 'Nicholson')
} catch (e) {
    assert e.message.contains ('Could not find matching constructor')
}</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeProperties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should properties be included in tuple constructor generation</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor

@TupleConstructor(includeProperties=false)
class Person {
    String firstName
    String lastName
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')

try {
    def p2 = new Person('Jack', 'Nicholson')
} catch(e) {
    // will fail because properties are not included
}</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeFields</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should fields be included in tuple constructor generation, in addition to properties</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor

@TupleConstructor(includeFields=true)
class Person {
    String firstName
    String lastName
    private String occupation
    public String toString() {
        "$firstName $lastName: $occupation"
    }
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson', occupation: 'Actor')
def p2 = new Person('Jack', 'Nicholson', 'Actor')

assert p1.firstName == p2.firstName
assert p1.lastName == p2.lastName
assert p1.toString() == 'Jack Nicholson: Actor'
assert p1.toString() == p2.toString()</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeSuperProperties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should properties from super classes be included in tuple constructor generation</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor

class Base {
    String occupation
}

@TupleConstructor(includeSuperProperties=true)
class Person extends Base {
    String firstName
    String lastName
    public String toString() {
        "$firstName $lastName: $occupation"
    }
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')

def p2 = new Person('Actor', 'Jack', 'Nicholson')

assert p1.firstName == p2.firstName
assert p1.lastName == p2.lastName
assert p1.toString() == 'Jack Nicholson: null'
assert p2.toString() == 'Jack Nicholson: Actor'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeSuperFields</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should fields from super classes be included in tuple constructor generation</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor

class Base {
    protected String occupation
    public String occupation() { this.occupation }
}

@TupleConstructor(includeSuperFields=true)
class Person extends Base {
    String firstName
    String lastName
    public String toString() {
        "$firstName $lastName: ${occupation()}"
    }
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson', occupation: 'Actor')

def p2 = new Person('Actor', 'Jack', 'Nicholson')

assert p1.firstName == p2.firstName
assert p1.lastName == p2.lastName
assert p1.toString() == 'Jack Nicholson: Actor'
assert p2.toString() == p1.toString()</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">callSuper</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should super properties be called within a call to the parent constructor rather than set as properties</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor

class Base {
    String occupation
    Base() {}
    Base(String job) { occupation = job?.toLowerCase() }
}

@TupleConstructor(includeSuperProperties = true, callSuper=true)
class Person extends Base {
    String firstName
    String lastName
    public String toString() {
        "$firstName $lastName: $occupation"
    }
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')

def p2 = new Person('ACTOR', 'Jack', 'Nicholson')

assert p1.firstName == p2.firstName
assert p1.lastName == p2.lastName
assert p1.toString() == 'Jack Nicholson: null'
assert p2.toString() == 'Jack Nicholson: actor'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">force</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">By default, the transformation will do nothing if a constructor is already defined. Setting this attribute to
true, the constructor will be generated and it&#8217;s your responsibility to ensure that no duplicate constructor is defined.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.*

@ToString @TupleConstructor(force=true)
final class Person {
    String name
    // explicit constructor would normally disable tuple constructor
    Person(String first, String last) { this("$first $last") }
}

assert new Person('john smith').toString() == 'Person(john smith)'
assert new Person('john', 'smith').toString() == 'Person(john smith)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">defaults</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates that default value processing is enabled for constructor parameters.
Set to false to obtain exactly one constructor but with initial value support and named-arguments disabled.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString
@TupleConstructor(defaults=false)
class Musician {
  String name
  String instrument
  int born
}

assert new Musician('Jimi', 'Guitar', 1942).toString() == 'Musician(Jimi, Guitar, 1942)'
assert Musician.constructors.size() == 1</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">useSetters</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">By default, the transformation will directly set the backing field of each property
from its corresponding constructor parameter. Setting this attribute to true, the constructor will instead call setters if
they exist. It&#8217;s usually deemed bad style from within a constructor to call setters that can be overridden. It&#8217;s your
responsibility to avoid such bad style.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.*

@ToString @TupleConstructor(useSetters=true)
final class Foo {
    String bar
    void setBar(String bar) {
        this.bar = bar?.toUpperCase() // null-safe
    }
}

assert new Foo('cat').toString() == 'Foo(CAT)'
assert new Foo(bar: 'cat').toString() == 'Foo(CAT)'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">allNames</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should fields and/or properties with internal names be included within the constructor</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor

@TupleConstructor(allNames=true)
class Person {
    String $firstName
}

def p = new Person('Jack')

assert p.$firstName == 'Jack'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">allProperties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should JavaBean properties be included within the constructor</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TupleConstructor(allProperties=true)
class Person {
    String first
    private String last
    void setLast(String last) {
        this.last = last
    }
    String getName() { "$first $last" }
}

assert new Person('john', 'smith').name == 'john smith'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pre</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">empty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A closure containing statements to be inserted at the start of the generated constructor(s)</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor

@TupleConstructor(pre={ first = first?.toLowerCase() })
class Person {
    String first
}

def p = new Person('Jack')

assert p.first == 'jack'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">post</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">empty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A closure containing statements to be inserted at the end of the generated constructor(s)</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.TupleConstructor
import static groovy.test.GroovyAssert.shouldFail

@TupleConstructor(post={ assert first })
class Person {
    String first
}

def jack = new Person('Jack')
shouldFail {
  def unknown = new Person()
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Setting the <code>defaults</code> annotation attribute to <code>false</code> and the <code>force</code> annotation attribute to <code>true</code> allows
multiple tuple constructors to be created by using different customization options for the different cases
(provided each case has a different type signature) as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Named {
  String name
}

@ToString(includeSuperProperties=true, ignoreNulls=true, includeNames=true, includeFields=true)
@TupleConstructor(force=true, defaults=false)
@TupleConstructor(force=true, defaults=false, includeFields=true)
@TupleConstructor(force=true, defaults=false, includeSuperProperties=true)
class Book extends Named {
  Integer published
  private Boolean fiction
  Book() {}
}

assert new Book("Regina", 2015).toString() == 'Book(published:2015, name:Regina)'
assert new Book(2015, false).toString() == 'Book(published:2015, fiction:false)'
assert new Book(2015).toString() == 'Book(published:2015)'
assert new Book().toString() == 'Book()'
assert Book.constructors.size() == 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, here is another example using different options for <code>includes</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ToString(includeSuperProperties=true, ignoreNulls=true, includeNames=true, includeFields=true)
@TupleConstructor(force=true, defaults=false, includes='name,year')
@TupleConstructor(force=true, defaults=false, includes='year,fiction')
@TupleConstructor(force=true, defaults=false, includes='name,fiction')
class Book {
    String name
    Integer year
    Boolean fiction
}

assert new Book("Regina", 2015).toString() == 'Book(name:Regina, year:2015)'
assert new Book(2015, false).toString() == 'Book(year:2015, fiction:false)'
assert new Book("Regina", false).toString() == 'Book(name:Regina, fiction:false)'
assert Book.constructors.size() == 3</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xform-MapConstructor"><a class="anchor" href="#xform-MapConstructor"></a><code>@groovy.transform.MapConstructor</code></h5>
<div class="paragraph">
<p>The <code>@MapConstructor</code> annotation aims at eliminating boilerplate code by generating a map constructor for you. A map
constructor is created such that each property in the class is set based on the value in the supplied map
having the key with the name of the property. Usage is as shown in this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.*

@ToString
@MapConstructor
class Person {
    String firstName
    String lastName
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
assert p1.toString() == 'Person(Jack, Nicholson)'</code></pre>
</div>
</div>
<div class="paragraph">
<p>The generated constructor will be roughly like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public Person(Map args) {
    if (args.containsKey('firstName')) {
        this.firstName = args.get('firstName')
    }
    if (args.containsKey('lastName')) {
        this.lastName = args.get('lastName')
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xform-Canonical"><a class="anchor" href="#xform-Canonical"></a><code>@groovy.transform.Canonical</code></h5>
<div class="paragraph">
<p>The <code>@Canonical</code> meta-annotation combines the <a href="#xform-ToString">@ToString</a>,
<a href="#xform-EqualsAndHashCode">@EqualsAndHashCode</a> and <a href="#xform-TupleConstructor">@TupleConstructor</a>
annotations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.Canonical

@Canonical
class Person {
    String firstName
    String lastName
}
def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
assert p1.toString() == 'Person(Jack, Nicholson)' // Effect of @ToString

def p2 = new Person('Jack','Nicholson') // Effect of @TupleConstructor
assert p2.toString() == 'Person(Jack, Nicholson)'

assert p1==p2 // Effect of @EqualsAndHashCode
assert p1.hashCode()==p2.hashCode() // Effect of @EqualsAndHashCode</code></pre>
</div>
</div>
<div class="paragraph">
<p>A similar immutable class can be generated using the <a href="#xform-Immutable">@Immutable</a> meta-annotation instead.
The <code>@Canonical</code> meta-annotation supports the configuration options found in the annotations
it aggregates. See those annotations for more details.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.Canonical

@Canonical(excludes=['lastName'])
class Person {
    String firstName
    String lastName
}
def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
assert p1.toString() == 'Person(Jack)' // Effect of @ToString(excludes=['lastName'])

def p2 = new Person('Jack') // Effect of @TupleConstructor(excludes=['lastName'])
assert p2.toString() == 'Person(Jack)'

assert p1==p2 // Effect of @EqualsAndHashCode(excludes=['lastName'])
assert p1.hashCode()==p2.hashCode() // Effect of @EqualsAndHashCode(excludes=['lastName'])</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@Canonical</code> meta-annotation can be used in conjunction with an explicit use one or more of its
component annotations, like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.Canonical

@Canonical(excludes=['lastName'])
class Person {
    String firstName
    String lastName
}
def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
assert p1.toString() == 'Person(Jack)' // Effect of @ToString(excludes=['lastName'])

def p2 = new Person('Jack') // Effect of @TupleConstructor(excludes=['lastName'])
assert p2.toString() == 'Person(Jack)'

assert p1==p2 // Effect of @EqualsAndHashCode(excludes=['lastName'])
assert p1.hashCode()==p2.hashCode() // Effect of @EqualsAndHashCode(excludes=['lastName'])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any applicable annotation attributes from <code>@Canonical</code> are passed along to the explicit annotation but
attributes already existing in the explicit annotation take precedence.</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-InheritConstructors"><a class="anchor" href="#xform-InheritConstructors"></a><code>@groovy.transform.InheritConstructors</code></h5>
<div class="paragraph">
<p>The <code>@InheritConstructor</code> AST transformation aims at generating constructors matching super constructors for you. This
is in particular useful when overriding exception classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.InheritConstructors

@InheritConstructors
class CustomException extends Exception {}

// all those are generated constructors
new CustomException()
new CustomException("A custom message")
new CustomException("A custom message", new RuntimeException())
new CustomException(new RuntimeException())

// Java 7 only
// new CustomException("A custom message", new RuntimeException(), false, true)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@InheritConstructor</code> AST transformation supports the following configuration options:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Default value</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">constructorAnnotations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether to carry over annotations from the constructor during copying</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Retention(RetentionPolicy.RUNTIME)
@Target([ElementType.CONSTRUCTOR])
public @interface ConsAnno {}

class Base {
  @ConsAnno Base() {}
}

@InheritConstructors(constructorAnnotations=true)
class Child extends Base {}

assert Child.constructors[0].annotations[0].annotationType().name == 'groovy.transform.Generated'
assert Child.constructors[0].annotations[1].annotationType().name == 'ConsAnno'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">parameterAnnotations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether to carry over annotations from the constructor parameters when copying the constructor</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Retention(RetentionPolicy.RUNTIME)
@Target([ElementType.PARAMETER])
public @interface ParamAnno {}

class Base {
  Base(@ParamAnno String name) {}
}

@InheritConstructors(parameterAnnotations=true)
class Child extends Base {}

assert Child.constructors[0].parameterAnnotations[0][0].annotationType().name == 'ParamAnno'</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="xform-Category"><a class="anchor" href="#xform-Category"></a><code>@groovy.lang.Category</code></h5>
<div class="paragraph">
<p>The <code>@Category</code> AST transformation simplifies the creation of Groovy categories. Historically, a Groovy category was
written like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class TripleCategory {
    public static Integer triple(Integer self) {
        3*self
    }
}
use (TripleCategory) {
    assert 9 == 3.triple()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@Category</code> transformation lets you write the same using an instance-style class, rather than a static class style.
This removes the need for having the first argument of each method being the receiver. The category can be written like
this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Category(Integer)
class TripleCategory {
    public Integer triple() { 3*this }
}
use (TripleCategory) {
    assert 9 == 3.triple()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the mixed in class can be referenced using <code>this</code> instead. It&#8217;s also worth noting that using instance fields
in a category class is inherently unsafe: categories are not stateful (like traits).</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-IndexedProperty"><a class="anchor" href="#xform-IndexedProperty"></a><code>@groovy.transform.IndexedProperty</code></h5>
<div class="paragraph">
<p>The <code>@IndexedProperty</code> annotation aims at generating indexed getters/setters for properties of list/array types.
This is in particular useful if you want to use a Groovy class from Java. While Groovy supports GPath to access properties,
this is not available from Java. The <code>@IndexedProperty</code> annotation will generate indexed properties of the following
form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SomeBean {
    @IndexedProperty String[] someArray = new String[2]
    @IndexedProperty List someList = []
}

def bean = new SomeBean()
bean.setSomeArray(0, 'value')
bean.setSomeList(0, 123)

assert bean.someArray[0] == 'value'
assert bean.someList == [123]</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xform-Lazy"><a class="anchor" href="#xform-Lazy"></a><code>@groovy.lang.Lazy</code></h5>
<div class="paragraph">
<p>The <code>@Lazy</code> AST transformation implements lazy initialization of fields. For example, the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SomeBean {
    @Lazy LinkedList myField
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>will produce the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">List $myField
List getMyField() {
    if ($myField!=null) { return $myField }
    else {
        $myField = new LinkedList()
        return $myField
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default value which is used to initialize the field is the default constructor of the declaration type. It is possible
to define a default value by using a closure on the right hand side of the property assignment, as in the following
example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>class SomeBean {
    @Lazy LinkedList myField = { ['a','b','c']}()
}</pre>
</div>
</div>
<div class="paragraph">
<p>In that case, the generated code looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>List $myField
List getMyField() {
    if ($myField!=null) { return $myField }
    else {
        $myField = { ['a','b','c']}()
        return $myField
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>If the field is declared volatile then initialization will be synchronized using the
<a href="http://en.wikipedia.org/wiki/Double-checked_locking">double-checked locking</a> pattern.</p>
</div>
<div class="paragraph">
<p>Using the <code>soft=true</code> parameter, the helper field will use a <code>SoftReference</code> instead, providing a simple way to
implement caching. In that case, if the garbage collector decides to collect the reference, initialization will occur
the next time the field is accessed.</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-Newify"><a class="anchor" href="#xform-Newify"></a><code>@groovy.lang.Newify</code></h5>
<div class="paragraph">
<p>The <code>@Newify</code> AST transformation is used to bring alternative syntaxes to construct objects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Using the <code>Python</code> style:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>@Newify([Tree,Leaf])
class TreeBuilder {
    Tree tree = Tree(Leaf('A'),Leaf('B'),Tree(Leaf('C')))
}</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>or using the <code>Ruby</code> style:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>@Newify([Tree,Leaf])
class TreeBuilder {
    Tree tree = Tree.new(Leaf.new('A'),Leaf.new('B'),Tree.new(Leaf.new('C')))
}</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Ruby</code> version can be disabled by setting the <code>auto</code> flag to <code>false</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-Sortable"><a class="anchor" href="#xform-Sortable"></a><code>@groovy.transform.Sortable</code></h5>
<div class="paragraph">
<p>The <code>@Sortable</code> AST transformation is used to help write classes that are <code>Comparable</code> and easily sorted
typically by numerous properties. It is easy to use as shown in the following example where we annotate
the <code>Person</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.Sortable

@Sortable class Person {
    String first
    String last
    Integer born
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The generated class has the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it implements the <code>Comparable</code> interface</p>
</li>
<li>
<p>it contains a <code>compareTo</code> method with an implementation based on the natural ordering of the <code>first</code>, <code>last</code> and <code>born</code> properties</p>
</li>
<li>
<p>it has three methods returning comparators: <code>comparatorByFirst</code>, <code>comparatorByLast</code> and <code>comparatorByBorn</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The generated <code>compareTo</code> method will look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public int compareTo(java.lang.Object obj) {
    if (this.is(obj)) {
        return 0
    }
    if (!(obj instanceof Person)) {
        return -1
    }
    java.lang.Integer value = this.first &lt;=&gt; obj.first
    if (value != 0) {
        return value
    }
    value = this.last &lt;=&gt; obj.last
    if (value != 0) {
        return value
    }
    value = this.born &lt;=&gt; obj.born
    if (value != 0) {
        return value
    }
    return 0
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As an example of the generated comparators, the <code>comparatorByFirst</code> comparator will have a <code>compare</code> method that looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public int compare(java.lang.Object arg0, java.lang.Object arg1) {
    if (arg0 == arg1) {
        return 0
    }
    if (arg0 != null &amp;&amp; arg1 == null) {
        return -1
    }
    if (arg0 == null &amp;&amp; arg1 != null) {
        return 1
    }
    return arg0.first &lt;=&gt; arg1.first
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Person</code> class can be used wherever a <code>Comparable</code> is expected and the generated comparators
wherever a <code>Comparator</code> is expected as shown by these examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def people = [
    new Person(first: 'Johnny', last: 'Depp', born: 1963),
    new Person(first: 'Keira', last: 'Knightley', born: 1985),
    new Person(first: 'Geoffrey', last: 'Rush', born: 1951),
    new Person(first: 'Orlando', last: 'Bloom', born: 1977)
]

assert people[0] &gt; people[2]
assert people.sort()*.last == ['Rush', 'Depp', 'Knightley', 'Bloom']
assert people.sort(false, Person.comparatorByFirst())*.first == ['Geoffrey', 'Johnny', 'Keira', 'Orlando']
assert people.sort(false, Person.comparatorByLast())*.last == ['Bloom', 'Depp', 'Knightley', 'Rush']
assert people.sort(false, Person.comparatorByBorn())*.last == ['Rush', 'Depp', 'Bloom', 'Knightley']</code></pre>
</div>
</div>
<div class="paragraph">
<p>Normally, all properties are used in the generated <code>compareTo</code> method in the priority order in which they are defined.
You can include or exclude certain properties from the generated <code>compareTo</code> method by giving a list of property names
in the <code>includes</code> or <code>excludes</code> annotation attributes. If using <code>includes</code>, the order of the property names given will
determine the priority of properties when comparing. To illustrate, consider the following <code>Person</code> class definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Sortable(includes='first,born') class Person {
    String last
    int born
    String first
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It will have two comparator methods <code>comparatorByFirst</code> and <code>comparatorByBorn</code> and the generated <code>compareTo</code> method will look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public int compareTo(java.lang.Object obj) {
    if (this.is(obj)) {
        return 0
    }
    if (!(obj instanceof Person)) {
        return -1
    }
    java.lang.Integer value = this.first &lt;=&gt; obj.first
    if (value != 0) {
        return value
    }
    value = this.born &lt;=&gt; obj.born
    if (value != 0) {
        return value
    }
    return 0
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This <code>Person</code> class can be used as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def people = [
    new Person(first: 'Ben', last: 'Affleck', born: 1972),
    new Person(first: 'Ben', last: 'Stiller', born: 1965)
]

assert people.sort()*.last == ['Stiller', 'Affleck']</code></pre>
</div>
</div>
<div class="paragraph">
<p>The behavior of the <code>@Sortable</code> AST transformation can be further changed using the following additional parameters:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Default value</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">allProperties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should JavaBean properties (ordered after native properties) be used</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.*

@Canonical(includeFields = true)
@Sortable(allProperties = true, includes = 'nameSize')
class Player {
  String name
  int getNameSize() { name.size() }
}

def finalists = [
  new Player('Serena'),
  new Player('Venus'),
  new Player('CoCo'),
  new Player('Mirjana')
]

assert finalists.sort()*.name == ['CoCo', 'Venus', 'Serena', 'Mirjana']</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">allNames</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should properties with "internal" names be used</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.*

@Canonical(allNames = true)
@Sortable(allNames = false)
class Player {
  String $country
  String name
}

def finalists = [
  new Player('USA', 'Serena'),
  new Player('USA', 'Venus'),
  new Player('USA', 'CoCo'),
  new Player('Croatian', 'Mirjana')
]

assert finalists.sort()*.name == ['Mirjana', 'CoCo', 'Serena', 'Venus']</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeSuperProperties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should super properties also be used (ordered first)</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
  String name
}

@Canonical(includeSuperProperties = true)
@Sortable(includeSuperProperties = true)
class Citizen extends Person {
  String country
}

def people = [
  new Citizen('Bob', 'Italy'),
  new Citizen('Cathy', 'Hungary'),
  new Citizen('Cathy', 'Egypt'),
  new Citizen('Bob', 'Germany'),
  new Citizen('Alan', 'France')
]

assert people.sort()*.name == ['Alan', 'Bob', 'Bob', 'Cathy', 'Cathy']
assert people.sort()*.country == ['France', 'Germany', 'Italy', 'Egypt', 'Hungary']</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="xform-Builder"><a class="anchor" href="#xform-Builder"></a><code>@groovy.transform.builder.Builder</code></h5>
<div class="paragraph">
<p>The <code>@Builder</code> AST transformation is used to help write classes that can be created using <em>fluent</em> api calls.
The transform supports multiple building strategies to cover a range of cases and there are a number
of configuration options to customize the building process. If you&#8217;re an AST hacker, you can also define your own
strategy class. The following table lists the available strategies that are bundled with Groovy and the
configuration options each strategy supports.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1112%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Strategy</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Description</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">builderClassName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">builderMethodName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">buildMethodName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">prefix</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">includes/excludes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeSuperProperties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">allNames</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SimpleStrategy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">chained setters</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">n/a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">n/a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">n/a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes, default "set"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">n/a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes, default <code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExternalStrategy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">explicit builder class, class being built untouched</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">n/a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">n/a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes, default "build"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes, default ""</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes, default <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes, default <code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DefaultStrategy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">creates a nested helper class</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes, default <em>&lt;TypeName&gt;</em>Builder</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes, default "builder"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes, default "build"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes, default ""</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes, default <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes, default <code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InitializerStrategy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">creates a nested helper class providing type-safe fluent creation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes, default <em>&lt;TypeName&gt;</em>Initializer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes, default "createInitializer"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes, default "create" but usually only used internally</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes, default ""</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes, default <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes, default <code>false</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<div class="title">SimpleStrategy</div>
<p>To use the <code>SimpleStrategy</code>, annotate your Groovy class using the <code>@Builder</code> annotation, and specify the strategy as shown in this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.builder.*

@Builder(builderStrategy=SimpleStrategy)
class Person {
    String first
    String last
    Integer born
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, just call the setters in a chained fashion as shown here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def p1 = new Person().setFirst('Johnny').setLast('Depp').setBorn(1963)
assert "$p1.first $p1.last" == 'Johnny Depp'</code></pre>
</div>
</div>
<div class="paragraph">
<p>For each property, a generated setter will be created which looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public Person setFirst(java.lang.String first) {
    this.first = first
    return this
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can specify a prefix as shown in this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.builder.*

@Builder(builderStrategy=SimpleStrategy, prefix="")
class Person {
    String first
    String last
    Integer born
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And calling the chained setters would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def p = new Person().first('Johnny').last('Depp').born(1963)
assert "$p.first $p.last" == 'Johnny Depp'</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use the <code>SimpleStrategy</code> in conjunction with <code>@TupleConstructor</code>. If your <code>@Builder</code>
annotation doesn&#8217;t have explicit <code>includes</code> or <code>excludes</code> annotation attributes but your <code>@TupleConstructor</code>
annotation does, the ones from <code>@TupleConstructor</code> will be re-used for <code>@Builder</code>. The same applies for any
annotation aliases which combine <code>@TupleConstructor</code> such as <code>@Canonical</code>.</p>
</div>
<div class="paragraph">
<p>The annotation attribute <code>useSetters</code> can be used if you have a setter which you want called as part of the
construction process. See the JavaDoc for details.</p>
</div>
<div class="paragraph">
<p>The annotation attributes <code>builderClassName</code>, <code>buildMethodName</code>, <code>builderMethodName</code>, <code>forClass</code> and <code>includeSuperProperties</code> are not supported for this strategy.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Groovy already has built-in building mechanisms. Don&#8217;t rush to using <code>@Builder</code> if the built-in mechanisms meet your needs. Some examples:
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def p2 = new Person(first: 'Keira', last: 'Knightley', born: 1985)
def p3 = new Person().with {
    first = 'Geoffrey'
    last = 'Rush'
    born = 1951
}</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">ExternalStrategy</div>
<p>To use the <code>ExternalStrategy</code>, create and annotate a Groovy builder class using the <code>@Builder</code> annotation, specify the
class the builder is for using <code>forClass</code> and indicate use of the <code>ExternalStrategy</code>.
Suppose you have the following class you would like a builder for:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String first
    String last
    int born
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>you explicitly create and use your builder class as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.builder.*

@Builder(builderStrategy=ExternalStrategy, forClass=Person)
class PersonBuilder { }

def p = new PersonBuilder().first('Johnny').last('Depp').born(1963).build()
assert "$p.first $p.last" == 'Johnny Depp'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the (normally empty) builder class you provide will be filled in with appropriate setters and a build method.
The generated build method will look something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public Person build() {
    Person _thePerson = new Person()
    _thePerson.first = first
    _thePerson.last = last
    _thePerson.born = born
    return _thePerson
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class you are creating the builder for can be any Java or Groovy class following the normal JavaBean conventions,
e.g. a no-arg constructor and setters for the properties. Here is an example using a Java class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.builder.*

@Builder(builderStrategy=ExternalStrategy, forClass=javax.swing.DefaultButtonModel)
class ButtonModelBuilder {}

def model = new ButtonModelBuilder().enabled(true).pressed(true).armed(true).rollover(true).selected(true).build()
assert model.isArmed()
assert model.isPressed()
assert model.isEnabled()
assert model.isSelected()
assert model.isRollover()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The generated builder can be customised using the <code>prefix</code>, <code>includes</code>, <code>excludes</code> and <code>buildMethodName</code> annotation attributes.
Here is an example illustrating various customisations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.builder.*
import groovy.transform.Canonical

@Canonical
class Person {
    String first
    String last
    int born
}

@Builder(builderStrategy=ExternalStrategy, forClass=Person, includes=['first', 'last'], buildMethodName='create', prefix='with')
class PersonBuilder { }

def p = new PersonBuilder().withFirst('Johnny').withLast('Depp').create()
assert "$p.first $p.last" == 'Johnny Depp'</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>builderMethodName</code> and <code>builderClassName</code> annotation attributes for <code>@Builder</code> aren&#8217;t applicable for this strategy.</p>
</div>
<div class="paragraph">
<p>You can use the <code>ExternalStrategy</code> in conjunction with <code>@TupleConstructor</code>. If your <code>@Builder</code> annotation doesn&#8217;t have
explicit <code>includes</code> or <code>excludes</code> annotation attributes but the <code>@TupleConstructor</code> annotation of the class you are creating
the builder for does, the ones from <code>@TupleConstructor</code> will be re-used for <code>@Builder</code>. The same applies for any
annotation aliases which combine <code>@TupleConstructor</code> such as <code>@Canonical</code>.</p>
</div>
<div class="paragraph">
<div class="title">DefaultStrategy</div>
<p>To use the <code>DefaultStrategy</code>, annotate your Groovy class using the <code>@Builder</code> annotation as shown in this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.builder.Builder

@Builder
class Person {
    String firstName
    String lastName
    int age
}

def person = Person.builder().firstName("Robert").lastName("Lewandowski").age(21).build()
assert person.firstName == "Robert"
assert person.lastName == "Lewandowski"
assert person.age == 21</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want, you can customize various aspects of the building process
using the <code>builderClassName</code>, <code>buildMethodName</code>, <code>builderMethodName</code>, <code>prefix</code>, <code>includes</code> and <code>excludes</code> annotation attributes,
some of which are used in the example here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.builder.Builder

@Builder(buildMethodName='make', builderMethodName='maker', prefix='with', excludes='age')
class Person {
    String firstName
    String lastName
    int age
}

def p = Person.maker().withFirstName("Robert").withLastName("Lewandowski").make()
assert "$p.firstName $p.lastName" == "Robert Lewandowski"</code></pre>
</div>
</div>
<div class="paragraph">
<p>This strategy also supports annotating static methods and constructors. In this case, the static method or constructor
parameters become the properties to use for building purposes and in the case of static methods, the return type
of the method becomes the target class being built. If you have more than one <code>@Builder</code> annotation used within
a class (at either the class, method or constructor positions) then it is up to you to ensure that the generated
helper classes and factory methods have unique names (i.e. no more than one can use the default name values).
Here is an example highlighting method and constructor usage (and also illustrating the renaming required for unique names).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.builder.*
import groovy.transform.*

@ToString
@Builder
class Person {
  String first, last
  int born

  Person(){}

  @Builder(builderClassName='MovieBuilder', builderMethodName='byRoleBuilder')
  Person(String roleName) {
     if (roleName == 'Jack Sparrow') {
         this.first = 'Johnny'; this.last = 'Depp'; this.born = 1963
     }
  }

  @Builder(builderClassName='NameBuilder', builderMethodName='nameBuilder', prefix='having', buildMethodName='fullName')
  static String join(String first, String last) {
      first + ' ' + last
  }

  @Builder(builderClassName='SplitBuilder', builderMethodName='splitBuilder')
  static Person split(String name, int year) {
      def parts = name.split(' ')
      new Person(first: parts[0], last: parts[1], born: year)
  }
}

assert Person.splitBuilder().name("Johnny Depp").year(1963).build().toString() == 'Person(Johnny, Depp, 1963)'
assert Person.byRoleBuilder().roleName("Jack Sparrow").build().toString() == 'Person(Johnny, Depp, 1963)'
assert Person.nameBuilder().havingFirst('Johnny').havingLast('Depp').fullName() == 'Johnny Depp'
assert Person.builder().first("Johnny").last('Depp').born(1963).build().toString() == 'Person(Johnny, Depp, 1963)'</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>forClass</code> annotation attribute is not supported for this strategy.</p>
</div>
<div class="paragraph">
<div class="title">InitializerStrategy</div>
<p>To use the <code>InitializerStrategy</code>, annotate your Groovy class using the <code>@Builder</code> annotation, and specify the strategy as shown in this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.builder.*
import groovy.transform.*

@ToString
@Builder(builderStrategy=InitializerStrategy)
class Person {
    String firstName
    String lastName
    int age
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your class will be locked down to have a single public constructor taking a "fully set" initializer.
It will also have a factory method to create the initializer. These are used as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@CompileStatic
def firstLastAge() {
    assert new Person(Person.createInitializer().firstName("John").lastName("Smith").age(21)).toString() == 'Person(John, Smith, 21)'
}
firstLastAge()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any attempt to use the initializer which doesn&#8217;t involve setting all the properties (though order is not important) will result in
a compilation error. If you don&#8217;t need this level of strictness, you don&#8217;t need to use <code>@CompileStatic</code>.</p>
</div>
<div class="paragraph">
<p>You can use the <code>InitializerStrategy</code> in conjunction with <code>@Canonical</code> and <code>@Immutable</code>. If your <code>@Builder</code> annotation
doesn&#8217;t have explicit <code>includes</code> or <code>excludes</code> annotation attributes but your <code>@Canonical</code> annotation does, the ones
from <code>@Canonical</code> will be re-used for <code>@Builder</code>. Here is an example using <code>@Builder</code> with <code>@Immutable</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.builder.*
import groovy.transform.*
import static groovy.transform.options.Visibility.PRIVATE

@Builder(builderStrategy=InitializerStrategy)
@Immutable
@VisibilityOptions(PRIVATE)
class Person {
    String first
    String last
    int born
}

def publicCons = Person.constructors
assert publicCons.size() == 1

@CompileStatic
def createFirstLastBorn() {
  def p = new Person(Person.createInitializer().first('Johnny').last('Depp').born(1963))
  assert "$p.first $p.last $p.born" == 'Johnny Depp 1963'
}

createFirstLastBorn()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The annotation attribute <code>useSetters</code> can be used if you have a setter which you want called as part of the
construction process. See the JavaDoc for details.</p>
</div>
<div class="paragraph">
<p>This strategy also supports annotating static methods and constructors. In this case, the static method or constructor
parameters become the properties to use for building purposes and in the case of static methods, the return type
of the method becomes the target class being built. If you have more than one <code>@Builder</code> annotation used within
a class (at either the class, method or constructor positions) then it is up to you to ensure that the generated
helper classes and factory methods have unique names (i.e. no more than one can use the default name values).
For an example of method and constructor usage but using the <code>DefaultStrategy</code> strategy, consult that strategy&#8217;s
documentation.</p>
</div>
<div class="paragraph">
<p>The annotation attribute <code>forClass</code> is not supported for this strategy.</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-AutoImplement"><a class="anchor" href="#xform-AutoImplement"></a><code>@groovy.transform.AutoImplement</code></h5>
<div class="paragraph">
<p>The <code>@AutoImplement</code> AST transformation supplies dummy implementations for any found abstract methods from
superclasses or interfaces. The dummy implementation is the same for all abstract methods found and can be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>essentially empty (exactly true for void methods and for methods with a return type, returns the default value for
that type)</p>
</li>
<li>
<p>a statement that throws a specified exception (with optional message)</p>
</li>
<li>
<p>some user supplied code</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The first example illustrates the default case. Our class is annotated with <code>@AutoImplement</code>,
has a superclass and a single interface as can be seen here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.AutoImplement

@AutoImplement
class MyNames extends AbstractList&lt;String&gt; implements Closeable { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>void close()</code> method from the
<code>Closeable</code> interface is supplied and left empty. Implementations are also supplied
for the three abstract methods from the super class. The <code>get</code>, <code>addAll</code> and <code>size</code> methods
have return types of <code>String</code>, <code>boolean</code> and <code>int</code> respectively with default values
<code>null</code>, <code>false</code> and <code>0</code>. We can use our class (and check the expected return type for one
of the methods) using the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert new MyNames().size() == 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also worthwhile examining the equivalent generated code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MyNames implements Closeable extends AbstractList&lt;String&gt; {

    String get(int param0) {
        return null
    }

    boolean addAll(Collection&lt;? extends String&gt; param0) {
        return false
    }

    void close() throws Exception {
    }

    int size() {
        return 0
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second example illustrates the simplest exception case. Our class is annotated with <code>@AutoImplement</code>,
has a superclass and an annotation attribute indicates that an <code>IOException</code> should be thrown if any of
our "dummy" methods are called. Here is the class definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@AutoImplement(exception=IOException)
class MyWriter extends Writer { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can use the class (and check the expected exception is thrown for one
of the methods) using the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import static groovy.test.GroovyAssert.shouldFail

shouldFail(IOException) {
  new MyWriter().flush()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also worthwhile examining the equivalent generated code where three void methods
have been provided all of which throw the supplied exception:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MyWriter extends Writer {

    void flush() throws IOException {
        throw new IOException()
    }

    void write(char[] param0, int param1, int param2) throws IOException {
        throw new IOException()
    }

    void close() throws Exception {
        throw new IOException()
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The third example illustrates the exception case with a supplied message. Our class is annotated with <code>@AutoImplement</code>,
implements an interface, and has annotation attributes to indicate that an <code>UnsupportedOperationException</code> with
<code>Not supported by MyIterator</code> as the message should be thrown for any supplied methods. Here is the class definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@AutoImplement(exception=UnsupportedOperationException, message='Not supported by MyIterator')
class MyIterator implements Iterator&lt;String&gt; { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can use the class (and check the expected exception is thrown and has the correct message
for one of the methods) using the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def ex = shouldFail(UnsupportedOperationException) {
     new MyIterator().hasNext()
}
assert ex.message == 'Not supported by MyIterator'</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also worthwhile examining the equivalent generated code where three void methods
have been provided all of which throw the supplied exception:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MyIterator implements Iterator&lt;String&gt; {

    boolean hasNext() {
        throw new UnsupportedOperationException('Not supported by MyIterator')
    }

    String next() {
        throw new UnsupportedOperationException('Not supported by MyIterator')
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The fourth example illustrates the case of user supplied code. Our class is annotated with <code>@AutoImplement</code>,
implements an interface, has an explcitly overriden <code>hasNext</code> method, and has an annotation attribute containing the
supplied code for any supplied methods. Here is the class definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@AutoImplement(code = { throw new UnsupportedOperationException('Should never be called but was called on ' + new Date()) })
class EmptyIterator implements Iterator&lt;String&gt; {
    boolean hasNext() { false }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can use the class (and check the expected exception is thrown and has a message of the expected form)
using the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def ex = shouldFail(UnsupportedOperationException) {
     new EmptyIterator().next()
}
assert ex.message.startsWith('Should never be called but was called on ')</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also worthwhile examining the equivalent generated code where the <code>next</code> method has been supplied:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class EmptyIterator implements java.util.Iterator&lt;String&gt; {

    boolean hasNext() {
        false
    }

    String next() {
        throw new UnsupportedOperationException('Should never be called but was called on ' + new Date())
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xform-NullCheck"><a class="anchor" href="#xform-NullCheck"></a><code>@groovy.transform.NullCheck</code></h5>
<div class="paragraph">
<p>The <code>@NullCheck</code> AST transformation adds null-check guard statements to constructors and methods
which cause those methods to fail early when supplied with null arguments.
It can be seen as a form of defensive programming.
The annotation can be added to individual methods or constructors, or to the class
in which case it will apply to all methods/constructors.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@NullCheck
String longerOf(String first, String second) {
    first.size() &gt;= second.size() ? first : second
}

assert longerOf('cat', 'canary') == 'canary'
def ex = shouldFail(IllegalArgumentException) {
    longerOf('cat', null)
}
assert ex.message == 'second cannot be null'</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_class_design_annotations"><a class="anchor" href="#_class_design_annotations"></a>2.1.2. Class design annotations</h4>
<div class="paragraph">
<p>This category of annotations are aimed at simplifying the implementation of well-known design patterns (delegation,
singleton, &#8230;&#8203;) by using a declarative style.</p>
</div>
<div class="sect4">
<h5 id="xform-BaseScript"><a class="anchor" href="#xform-BaseScript"></a><code>@groovy.transform.BaseScript</code></h5>
<div class="paragraph">
<p><code>@BaseScript</code> is used within scripts to indicate that the script should
extend fron a custom script base class rather than <code>groovy.lang.Script</code>.
See the documentation for <a href="#dsl-basescript">domain specific languages</a> for further details.</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-Delegate"><a class="anchor" href="#xform-Delegate"></a><code>@groovy.lang.Delegate</code></h5>
<div class="paragraph">
<p>The <code>@Delegate</code> AST transformation aims at implementing the delegation design pattern. In the following class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Event {
    @Delegate Date when
    String title
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>when</code> property is annotated with <code>@Delegate</code>, meaning that the <code>Event</code> class will delegate calls to <code>Date</code> methods
to the <code>when</code> property. In this case, the generated code looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Event {
    Date when
    String title
    boolean before(Date other) {
        when.before(other)
    }
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you can call the <code>before</code> method, for example, directly on the <code>Event</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def ev = new Event(title:'Groovy keynote', when: Date.parse('yyyy/MM/dd', '2013/09/10'))
def now = new Date()
assert ev.before(now)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of annotating a property (or field), you can also annotate a method.
In this case, the method can be thought of as a getter or factory method for the delegate.
As an example, here is a class which (rather unusually) has a pool of delegates which are
accessed in a round-robin fashion:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Test {
    private int robinCount = 0
    private List&lt;List&gt; items = [[0], [1], [2]]

    @Delegate
    List getRoundRobinList() {
        items[robinCount++ % items.size()]
    }

    void checkItems(List&lt;List&gt; testValue) {
        assert items == testValue
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is an example usage of that class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def t = new Test()
t &lt;&lt; 'fee'
t &lt;&lt; 'fi'
t &lt;&lt; 'fo'
t &lt;&lt; 'fum'
t.checkItems([[0, 'fee', 'fum'], [1, 'fi'], [2, 'fo']])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using a standard list in this round-robin fashion would violate many expected properties of lists, so
don&#8217;t expect the above class to do anything useful beyond this trivial example.</p>
</div>
<div class="paragraph">
<p>The behavior of the <code>@Delegate</code> AST transformation can be changed using the following parameters:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Default value</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">interfaces</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should the interfaces implemented by the field be implemented by the class too</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Greeter { void sayHello() }
class MyGreeter implements Greeter { void sayHello() { println 'Hello!'} }

class DelegatingGreeter { // no explicit interface
    @Delegate MyGreeter greeter = new MyGreeter()
}
def greeter = new DelegatingGreeter()
assert greeter instanceof Greeter // interface was added transparently</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">deprecated</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If true, also delegates methods annotated with @Deprecated</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class WithDeprecation {
    @Deprecated
    void foo() {}
}
class WithoutDeprecation {
    @Deprecated
    void bar() {}
}
class Delegating {
    @Delegate(deprecated=true) WithDeprecation with = new WithDeprecation()
    @Delegate WithoutDeprecation without = new WithoutDeprecation()
}
def d = new Delegating()
d.foo() // passes thanks to deprecated=true
d.bar() // fails because of @Deprecated</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">methodAnnotations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether to carry over annotations from the methods of the delegate to your delegating method.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class WithAnnotations {
    @Transactional
    void method() {
    }
}
class DelegatingWithoutAnnotations {
    @Delegate WithAnnotations delegate
}
class DelegatingWithAnnotations {
    @Delegate(methodAnnotations = true) WithAnnotations delegate
}
def d1 = new DelegatingWithoutAnnotations()
def d2 = new DelegatingWithAnnotations()
assert d1.class.getDeclaredMethod('method').annotations.length==1
assert d2.class.getDeclaredMethod('method').annotations.length==2</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">parameterAnnotations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether to carry over annotations from the method parameters of the delegate to your delegating method.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class WithAnnotations {
    void method(@NotNull String str) {
    }
}
class DelegatingWithoutAnnotations {
    @Delegate WithAnnotations delegate
}
class DelegatingWithAnnotations {
    @Delegate(parameterAnnotations = true) WithAnnotations delegate
}
def d1 = new DelegatingWithoutAnnotations()
def d2 = new DelegatingWithAnnotations()
assert d1.class.getDeclaredMethod('method',String).parameterAnnotations[0].length==0
assert d2.class.getDeclaredMethod('method',String).parameterAnnotations[0].length==1</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">excludes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Empty array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A list of methods to be excluded from delegation. For more fine-grained control, see also <code>excludeTypes</code>.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Worker {
    void task1() {}
    void task2() {}
}
class Delegating {
    @Delegate(excludes=['task2']) Worker worker = new Worker()
}
def d = new Delegating()
d.task1() // passes
d.task2() // fails because method is excluded</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Undefined marker array (indicates all methods)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A list of methods to be included in delegation. For more
fine-grained
control, see also <code>includeTypes</code>.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Worker {
    void task1() {}
    void task2() {}
}
class Delegating {
    @Delegate(includes=['task1']) Worker worker = new Worker()
}
def d = new Delegating()
d.task1() // passes
d.task2() // fails because method is not included</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">excludeTypes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Empty array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A list of interfaces containing method signatures to be excluded from delegation</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface AppendStringSelector {
    StringBuilder append(String str)
}
class UpperStringBuilder {
    @Delegate(excludeTypes=AppendStringSelector)
    StringBuilder sb1 = new StringBuilder()

    @Delegate(includeTypes=AppendStringSelector)
    StringBuilder sb2 = new StringBuilder()

    String toString() { sb1.toString() + sb2.toString().toUpperCase() }
}
def usb = new UpperStringBuilder()
usb.append(3.5d)
usb.append('hello')
usb.append(true)
assert usb.toString() == '3.5trueHELLO'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeTypes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Undefined marker array (indicates no list be default)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A list of interfaces containing method signatures to
 be included in delegation</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface AppendBooleanSelector {
    StringBuilder append(boolean b)
}
interface AppendFloatSelector {
    StringBuilder append(float b)
}
class NumberBooleanBuilder {
    @Delegate(includeTypes=AppendBooleanSelector, interfaces=false)
    StringBuilder nums = new StringBuilder()
    @Delegate(includeTypes=[AppendFloatSelector], interfaces=false)
    StringBuilder bools = new StringBuilder()
    String result() { "${nums.toString()} ~ ${bools.toString()}" }
}
def b = new NumberBooleanBuilder()
b.append(true)
b.append(3.14f)
b.append(false)
b.append(0.0f)
assert b.result() == "truefalse ~ 3.140.0"
b.append(3.5d) // would fail because we didn't include append(double)</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">allNames</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should the delegate pattern be also applied to methods with internal names</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Worker {
    void task$() {}
}
class Delegating {
    @Delegate(allNames=true) Worker worker = new Worker()
}
def d = new Delegating()
d.task$() //passes</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="xform-Immutable"><a class="anchor" href="#xform-Immutable"></a><code>@groovy.transform.Immutable</code></h5>
<div class="paragraph">
<p>The <code>@Immutable</code> meta-annotation combines the following annotations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#xform-ToString">@ToString</a></p>
</li>
<li>
<p><a href="#xform-EqualsAndHashCode">@EqualsAndHashCode</a></p>
</li>
<li>
<p><a href="#xform-TupleConstructor">@TupleConstructor</a></p>
</li>
<li>
<p><a href="#xform-MapConstructor">@MapConstructor</a></p>
</li>
<li>
<p><a href="#xform-ImmutableBase">@ImmutableBase</a></p>
</li>
<li>
<p><a href="#xform-ImmutableOptions">@ImmutableOptions</a></p>
</li>
<li>
<p><a href="#xform-PropertyOptions">@PropertyOptions</a></p>
</li>
<li>
<p><a href="#xform-KnownImmutable">@KnownImmutable</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>@Immutable</code> meta-annotation simplifies the creation of immutable classes. Immutable classes are useful
since they are often easier to reason about and are inherently thread-safe.
See <a href="http://www.informit.com/store/effective-java-9780134685991">Effective Java, Minimize Mutability</a> for all the details
about how to achieve immutable classes in Java. The <code>@Immutable</code> meta-annotation does most of the things described
in <em>Effective Java</em> for you automatically.
To use the meta-annotation, all you have to do is annotate the class like in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.Immutable

@Immutable
class Point {
    int x
    int y
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>One of the requirements for immutable classes is that there is no way to modify any state information within the class.
One requirement to achieve this is to use immutable classes for each property or alternatively perform special coding
such as defensive copy in and defensive copy out for any mutable properties within the constructors
and property getters. Between <code>@ImmutableBase</code>, <code>@MapConstructor</code> and <code>@TupleConstructor</code> properties
are either identified as immutable or the special coding for numerous known cases is handled automatically.
Various mechanisms are provided for you to extend the handled property types which are allowed. See
<code>@ImmutableOptions</code> and <code>@KnownImmutable</code> for details.</p>
</div>
<div class="paragraph">
<p>The results of applying <code>@Immutable</code> to a class are pretty similar to those of
applying the <a href="#xform-Canonical">@Canonical</a> meta-annotation but the generated class will have extra
logic to handle immutability. You will observe this by, for instance, trying to modify a property
which will result in a <code>ReadOnlyPropertyException</code> being thrown since the backing field for the property
will have been automatically made final.</p>
</div>
<div class="paragraph">
<p>The <code>@Immutable</code> meta-annotation supports the configuration options found in the annotations
it aggregates. See those annotations for more details.</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-ImmutableBase"><a class="anchor" href="#xform-ImmutableBase"></a><code>@groovy.transform.ImmutableBase</code></h5>
<div class="paragraph">
<p>Immutable classes generated with <code>@ImmutableBase</code> are automatically made final. Also, the type of each property is checked
and various checks are made on the class, for example, public instance fields currently aren&#8217;t allowed. It also generates
a <code>copyWith</code> constructor if desired.</p>
</div>
<div class="paragraph">
<p>The following annotation attribute is supported:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Default value</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">copyWith</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A boolean whether to generate a <code>copyWith( Map )</code> method.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.Immutable

@Immutable( copyWith=true )
class User {
    String  name
    Integer age
}

def bob   = new User( 'bob', 43 )
def alice = bob.copyWith( name:'alice' )
assert alice.name == 'alice'
assert alice.age  == 43</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="xform-PropertyOptions"><a class="anchor" href="#xform-PropertyOptions"></a><code>@groovy.transform.PropertyOptions</code></h5>
<div class="paragraph">
<p>This annotation allows you to specify a custom property handler to be used by transformations
during class construction. It is ignored by the main Groovy compiler but is referenced by other transformations
like <code>@TupleConstructor</code>, <code>@MapConstructor</code>, and <code>@ImmutableBase</code>. It is frequently used behind the
scenes by the <code>@Immutable</code> meta-annotation.</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-VisibilityOptions"><a class="anchor" href="#xform-VisibilityOptions"></a><code>@groovy.transform.VisibilityOptions</code></h5>
<div class="paragraph">
<p>This annotation allows you to specify a custom visibility for a construct generated by another transformation.
It is ignored by the main Groovy compiler but is referenced by other transformations
like <code>@TupleConstructor</code>, <code>@MapConstructor</code>, and <code>@NamedVariant</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-ImumtableOptions"><a class="anchor" href="#xform-ImumtableOptions"></a><code>@groovy.transform.ImmutableOptions</code></h5>
<div class="paragraph">
<p>Groovy&#8217;s immutability support relies on a predefined list of known immutable classes (like <code>java.net.URI</code> or <code>java.lang.String</code>
and fails if you use a type which is not in that list, you are allowed to add to the list of known immutable types
thanks to the following annotation attributes of the <code>@ImmutableOptions</code> annotation:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Default value</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">knownImmutableClasses</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Empty list</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A list of classes which are deemed immutable.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.Immutable
import groovy.transform.TupleConstructor

@TupleConstructor
final class Point {
    final int x
    final int y
    public String toString() { "($x,$y)" }
}

@Immutable(knownImmutableClasses=[Point])
class Triangle {
    Point a,b,c
}</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">knownImmutables</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Empty list</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A list of property names which are deemed immutable.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.Immutable
import groovy.transform.TupleConstructor

@TupleConstructor
final class Point {
    final int x
    final int y
    public String toString() { "($x,$y)" }
}

@Immutable(knownImmutables=['a','b','c'])
class Triangle {
    Point a,b,c
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>If you deem a type as immutable and it isn&#8217;t one of the ones automatically handled, then it is up to you
to correctly code that class to ensure immutability.</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-KnownImmutable"><a class="anchor" href="#xform-KnownImmutable"></a><code>@groovy.transform.KnownImmutable</code></h5>
<div class="paragraph">
<p>The <code>@KnownImmutable</code> annotation isn&#8217;t actually one that triggers any AST transformations. It is simply
a marker annotation. You can annotate your classes with the annotation (including Java classes) and they
will be recognized as acceptable types for members within an immutable class. This saves you having to
explicitly use the <code>knownImmutables</code> or <code>knownImmutableClasses</code> annotation attributes from <code>@ImmutableOptions</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-Memoized"><a class="anchor" href="#xform-Memoized"></a><code>@groovy.transform.Memoized</code></h5>
<div class="paragraph">
<p>The <code>@Memoized</code> AST transformations simplifies the implementation of caching by allowing the result of method calls
to be cached just by annotating the method with <code>@Memoized</code>. Let&#8217;s imagine the following method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">long longComputation(int seed) {
    // slow computation
    Thread.sleep(100*seed)
    System.nanoTime()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This emulates a long computation, based on the actual parameters of the method. Without <code>@Memoized</code>, each method call
would take several seconds plus it would return a random result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def x = longComputation(1)
def y = longComputation(1)
assert x!=y</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adding <code>@Memoized</code> changes the semantics of the method by adding caching, based on the parameters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Memoized
long longComputation(int seed) {
    // slow computation
    Thread.sleep(100*seed)
    System.nanoTime()
}

def x = longComputation(1) // returns after 100 milliseconds
def y = longComputation(1) // returns immediatly
def z = longComputation(2) // returns after 200 milliseconds
assert x==y
assert x!=z</code></pre>
</div>
</div>
<div class="paragraph">
<p>The size of the cache can be configured using two optional parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>protectedCacheSize</em>: the number of results which are guaranteed not to be cleared after garbage collection</p>
</li>
<li>
<p><em>maxCacheSize</em>: the maximum number of results that can be kept in memory</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By default, the size of the cache is unlimited and no cache result is protected from garbage collection. Setting a
<em>protectedCacheSize&gt;0</em> would create an unlimited cache with some results protected. Setting <em>maxCacheSize&gt;0</em> would
 create a limited cache but without any protection from garbage protection. Setting both would create a limited,
 protected cache.</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-TailRecursive"><a class="anchor" href="#xform-TailRecursive"></a><code>@groovy.transform.TailRecursive</code></h5>
<div class="paragraph">
<p>The <code>@TailRecursive</code> annotation can be used to automatically transform a recursive call at the end of a method
into an equivalent iterative version of the same code. This avoids stack overflow due to too many recursive calls.
Below is an example of use when calculating factorial:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.CompileStatic
import groovy.transform.TailRecursive

@CompileStatic
class Factorial {

    @TailRecursive
    static BigInteger factorial( BigInteger i, BigInteger product = 1) {
        if( i == 1) {
            return product
        }
        return factorial(i-1, product*i)
    }
}

assert Factorial.factorial(1) == 1
assert Factorial.factorial(3) == 6
assert Factorial.factorial(5) == 120
assert Factorial.factorial(50000).toString().size() == 213237 // Big number and no Stack Overflow</code></pre>
</div>
</div>
<div class="paragraph">
<p>Currently, the annotation will only work for self-recursive method calls, i.e. a single recursive call to the exact same method again.
Consider using Closures and <code>trampoline()</code> if you have a scenario involving simple mutual recursion.
Also note that only non-void methods are currently handled (void calls will result in a compilation error).</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Currently, some forms of method overloading can trick the compiler,
and some non-tail recursive calls are erroneously treated as tail recursive.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="xform-Singleton"><a class="anchor" href="#xform-Singleton"></a><code>@groovy.lang.Singleton</code></h5>
<div class="paragraph">
<p>The <code>@Singleton</code> annotation can be used to implement the singleton design pattern on a class. The singleton instance
is defined eagerly by default, using class initialization, or lazily, in which case the field is initialized using
double checked locking.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Singleton
class GreetingService {
    String greeting(String name) { "Hello, $name!" }
}
assert GreetingService.instance.greeting('Bob') == 'Hello, Bob!'</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, the singleton is created eagerly when the class is initialized and available through the <code>instance</code> property.
It is possible to change the name of the singleton using the <code>property</code> parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Singleton(property='theOne')
class GreetingService {
    String greeting(String name) { "Hello, $name!" }
}

assert GreetingService.theOne.greeting('Bob') == 'Hello, Bob!'</code></pre>
</div>
</div>
<div class="paragraph">
<p>And it is also possible to make initialization lazy using the <code>lazy</code> parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Collaborator {
    public static boolean init = false
}
@Singleton(lazy=true,strict=false)
class GreetingService {
    static void init() {}
    GreetingService() {
        Collaborator.init = true
    }
    String greeting(String name) { "Hello, $name!" }
}
GreetingService.init() // make sure class is initialized
assert Collaborator.init == false
GreetingService.instance
assert Collaborator.init == true
assert GreetingService.instance.greeting('Bob') == 'Hello, Bob!'</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, we also set the <code>strict</code> parameter to false, which allows us to define our own constructor.</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-Mixin"><a class="anchor" href="#xform-Mixin"></a><code>@groovy.lang.Mixin</code></h5>
<div class="paragraph">
<p>Deprecated. Consider using traits instead.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_logging_improvements"><a class="anchor" href="#_logging_improvements"></a>2.1.3. Logging improvements</h4>
<div class="paragraph">
<p>Groovy provides AST transformation that helps integrating with the most widely used logging frameworks. It&#8217;s worth noting
that annotating a class with one of those annotations doesn&#8217;t prevent you from adding the appropriate logging framework
on classpath.</p>
</div>
<div class="paragraph">
<p>All transformations work in a similar way:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>add static final <code>log</code> field corresponding to the logger</p>
</li>
<li>
<p>wrap all calls to <code>log.level()</code> into the appropriate <code>log.isLevelEnabled</code> guard, depending on the underlying framework</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Those transformations support two parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>value</code> (default <code>log</code>) corresponds to the name of the logger field</p>
</li>
<li>
<p><code>category</code> (defaults to the class name) is the name of the logger category</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="xform-Log"><a class="anchor" href="#xform-Log"></a><code>@groovy.util.logging.Log</code></h5>
<div class="paragraph">
<p>The first logging AST transformation available is the <code>@Log</code> annotation which relies on the JDK logging framework. Writing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.util.logging.Log
class Greeter {
    void greet() {
        log.info 'Called greeter'
        println 'Hello, world!'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to writing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import java.util.logging.Level
import java.util.logging.Logger

class Greeter {
    private static final Logger log = Logger.getLogger(Greeter.name)
    void greet() {
        if (log.isLoggable(Level.INFO)) {
            log.info 'Called greeter'
        }
        println 'Hello, world!'
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xform-Commons"><a class="anchor" href="#xform-Commons"></a><code>@groovy.util.logging.Commons</code></h5>
<div class="paragraph">
<p>Groovy supports the <a href="http://commons.apache.org/proper/commons-logging/">Apache Commons Logging</a> framework using to the
<code>@Commons</code> annotation. Writing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.util.logging.Commons
class Greeter {
    void greet() {
        log.debug 'Called greeter'
        println 'Hello, world!'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to writing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.apache.commons.logging.LogFactory
import org.apache.commons.logging.Log

class Greeter {
    private static final Log log = LogFactory.getLog(Greeter)
    void greet() {
        if (log.isDebugEnabled()) {
            log.debug 'Called greeter'
        }
        println 'Hello, world!'
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xform-Log4j"><a class="anchor" href="#xform-Log4j"></a><code>@groovy.util.logging.Log4j</code></h5>
<div class="paragraph">
<p>Groovy supports the <a href="http://logging.apache.org/log4j/1.2/">Apache Log4j 1.x</a> framework using to the
<code>@Log4j</code> annotation. Writing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.util.logging.Log4j
class Greeter {
    void greet() {
        log.debug 'Called greeter'
        println 'Hello, world!'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to writing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.apache.log4j.Logger

class Greeter {
    private static final Logger log = Logger.getLogger(Greeter)
    void greet() {
        if (log.isDebugEnabled()) {
            log.debug 'Called greeter'
        }
        println 'Hello, world!'
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xform-Log4j2"><a class="anchor" href="#xform-Log4j2"></a><code>@groovy.util.logging.Log4j2</code></h5>
<div class="paragraph">
<p>Groovy supports the <a href="http://logging.apache.org/log4j/2.x/">Apache Log4j 2.x</a> framework using to the
<code>@Log4j2</code> annotation. Writing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.util.logging.Log4j2
class Greeter {
    void greet() {
        log.debug 'Called greeter'
        println 'Hello, world!'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to writing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.apache.logging.log4j.LogManager
import org.apache.logging.log4j.Logger

class Greeter {
    private static final Logger log = LogManager.getLogger(Greeter)
    void greet() {
        if (log.isDebugEnabled()) {
            log.debug 'Called greeter'
        }
        println 'Hello, world!'
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xform-Slf4j"><a class="anchor" href="#xform-Slf4j"></a><code>@groovy.util.logging.Slf4j</code></h5>
<div class="paragraph">
<p>Groovy supports the <a href="http://www.slf4j.org/">Simple Logging Facade for Java (SLF4J)</a> framework using to the
<code>@Slf4j</code> annotation. Writing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@groovy.util.logging.Slf4j
class Greeter {
    void greet() {
        log.debug 'Called greeter'
        println 'Hello, world!'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to writing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.slf4j.LoggerFactory
import org.slf4j.Logger

class Greeter {
    private static final Logger log = LoggerFactory.getLogger(Greeter)
    void greet() {
        if (log.isDebugEnabled()) {
            log.debug 'Called greeter'
        }
        println 'Hello, world!'
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_declarative_concurrency"><a class="anchor" href="#_declarative_concurrency"></a>2.1.4. Declarative concurrency</h4>
<div class="paragraph">
<p>The Groovy language provides a set of annotations aimed at simplifying common concurrency patterns in a declarative
approach.</p>
</div>
<div class="sect4">
<h5 id="xform-Synchronized"><a class="anchor" href="#xform-Synchronized"></a><code>@groovy.transform.Synchronized</code></h5>
<div class="paragraph">
<p>The <code>@Synchronized</code> AST transformations works in a similar way to the <code>synchronized</code> keyword but locks on different
objects for safer concurrency. It can be applied on any method or static method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.Synchronized

import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit

class Counter {
    int cpt
    @Synchronized
    int incrementAndGet() {
        cpt++
    }
    int get() {
        cpt
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Writing this is equivalent to creating a lock object and wrapping the whole method into a synchronized block:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Counter {
    int cpt
    private final Object $lock = new Object()

    int incrementAndGet() {
        synchronized($lock) {
            cpt++
        }
    }
    int get() {
        cpt
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, <code>@Synchronized</code> creates a field named <code>$lock</code> (or <code>$LOCK</code> for a static method) but you can make it use any
field you want by specifying the value attribute, like in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.Synchronized

import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit

class Counter {
    int cpt
    private final Object myLock = new Object()

    @Synchronized('myLock')
    int incrementAndGet() {
        cpt++
    }
    int get() {
        cpt
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xform-WithReadLock"><a class="anchor" href="#xform-WithReadLock"></a><code>@groovy.transform.WithReadLock</code> and <code>@groovy.transform.WithWriteLock</code></h5>
<div class="paragraph">
<p>The <code>@WithReadLock</code> AST transformation works in conjunction with the <code>@WithWriteLock</code> transformation
to provide read/write synchronization using the <code>ReentrantReadWriteLock</code> facility that the JDK provides. The annotation
can be added to a method or a static method. It will transparently create a <code>$reentrantLock</code> final field (or
<code>$REENTRANTLOCK</code> for a static method) and proper synchronization code will be added. For example, the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.WithReadLock
import groovy.transform.WithWriteLock

class Counters {
    public final Map&lt;String,Integer&gt; map = [:].withDefault { 0 }

    @WithReadLock
    int get(String id) {
        map.get(id)
    }

    @WithWriteLock
    void add(String id, int num) {
        Thread.sleep(200) // emulate long computation
        map.put(id, map.get(id)+num)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.WithReadLock as WithReadLock
import groovy.transform.WithWriteLock as WithWriteLock

public class Counters {

    private final Map&lt;String, Integer&gt; map
    private final java.util.concurrent.locks.ReentrantReadWriteLock $reentrantlock

    public int get(java.lang.String id) {
        $reentrantlock.readLock().lock()
        try {
            map.get(id)
        }
        finally {
            $reentrantlock.readLock().unlock()
        }
    }

    public void add(java.lang.String id, int num) {
        $reentrantlock.writeLock().lock()
        try {
            java.lang.Thread.sleep(200)
            map.put(id, map.get(id) + num )
        }
        finally {
            $reentrantlock.writeLock().unlock()
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Both <code>@WithReadLock</code> and <code>@WithWriteLock</code> support specifying an alternative lock object. In that case, the referenced
 field must be declared by the user, like in the following alternative:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.WithReadLock
import groovy.transform.WithWriteLock

import java.util.concurrent.locks.ReentrantReadWriteLock

class Counters {
    public final Map&lt;String,Integer&gt; map = [:].withDefault { 0 }
    private final ReentrantReadWriteLock customLock = new ReentrantReadWriteLock()

    @WithReadLock('customLock')
    int get(String id) {
        map.get(id)
    }

    @WithWriteLock('customLock')
    void add(String id, int num) {
        Thread.sleep(200) // emulate long computation
        map.put(id, map.get(id)+num)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For details</p>
</div>
<div class="ulist">
<ul>
<li>
<p>See Javadoc for <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/WithReadLock.html">groovy.transform.WithReadLock</a></p>
</li>
<li>
<p>See Javadoc for <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/WithWriteLock.html">groovy.transform.WithWriteLock</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_easier_cloning_and_externalizing"><a class="anchor" href="#_easier_cloning_and_externalizing"></a>2.1.5. Easier cloning and externalizing</h4>
<div class="paragraph">
<p>Groovy provides two annotations aimed at facilitating the implementation of <code>Cloneable</code> and <code>Externalizable</code> interfaces,
respectively named <code>@AutoClone</code> and <code>@AutoExternalize</code>.</p>
</div>
<div class="sect4">
<h5 id="xform-AutoClone"><a class="anchor" href="#xform-AutoClone"></a><code>@groovy.transform.AutoClone</code></h5>
<div class="paragraph">
<p>The <code>@AutoClone</code> annotation is aimed at implementing the <code>@java.lang.Cloneable</code> interface using various strategies, thanks to the <code>style</code> parameter:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the default <code>AutoCloneStyle.CLONE</code> strategy calls <code>super.clone()</code> first then <code>clone()</code> on each cloneable property</p>
</li>
<li>
<p>the <code>AutoCloneStyle.SIMPLE</code> strategy uses a regular constructor call and copies properties from the source to the clone</p>
</li>
<li>
<p>the <code>AutoCloneStyle.COPY_CONSTRUCTOR</code> strategy creates and uses a copy constructor</p>
</li>
<li>
<p>the <code>AutoCloneStyle.SERIALIZATION</code> strategy uses serialization (or externalization) to clone the object</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each of those strategies have pros and cons which are discussed in the Javadoc for <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/AutoClone.html">groovy.transform.AutoClone</a> and <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/AutoCloneStyle.html">groovy.transform.AutoCloneStyle</a> .</p>
</div>
<div class="paragraph">
<p>For example, the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.AutoClone

@AutoClone
class Book {
    String isbn
    String title
    List&lt;String&gt; authors
    Date publicationDate
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Book implements Cloneable {
    String isbn
    String title
    List&lt;String&gt; authors
    Date publicationDate

    public Book clone() throws CloneNotSupportedException {
        Book result = super.clone()
        result.authors = authors instanceof Cloneable ? (List) authors.clone() : authors
        result.publicationDate = publicationDate.clone()
        result
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the String properties aren&#8217;t explicitly handled because Strings are immutable and the <code>clone()</code> method from <code>Object</code> will copy the String references. The same would apply to primitive fields and most of the concrete subclasses of <code>java.lang.Number</code>.</p>
</div>
<div class="paragraph">
<p>In addition to cloning styles, <code>@AutoClone</code> supports multiple options:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Default value</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">excludes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Empty list</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A list of property or field names that need to be excluded from cloning. A string consisting of a comma-separated field/property names is also allowed.
See <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/AutoClone.html#excludes">groovy.transform.AutoClone#excludes</a> for details</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.AutoClone
import groovy.transform.AutoCloneStyle

@AutoClone(style=AutoCloneStyle.SIMPLE,excludes='authors')
class Book {
    String isbn
    String title
    List authors
    Date publicationDate
}</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeFields</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">By default, only properties are cloned. Setting this flag to true will also clone fields.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.AutoClone
import groovy.transform.AutoCloneStyle

@AutoClone(style=AutoCloneStyle.SIMPLE,includeFields=true)
class Book {
    String isbn
    String title
    List authors
    protected Date publicationDate
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="xform-AutoExternalize"><a class="anchor" href="#xform-AutoExternalize"></a><code>@groovy.transform.AutoExternalize</code></h5>
<div class="paragraph">
<p>The <code>@AutoExternalize</code> AST transformation will assist in the creation of <code>java.io.Externalizable</code> classes. It will
automatically add the interface to the class and generate the <code>writeExternal</code> and <code>readExternal</code> methods. For example, this
code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.AutoExternalize

@AutoExternalize
class Book {
    String isbn
    String title
    float price
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>will be converted into:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Book implements java.io.Externalizable {
    String isbn
    String title
    float price

    void writeExternal(ObjectOutput out) throws IOException {
        out.writeObject(isbn)
        out.writeObject(title)
        out.writeFloat( price )
    }

    public void readExternal(ObjectInput oin) {
        isbn = (String) oin.readObject()
        title = (String) oin.readObject()
        price = oin.readFloat()
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@AutoExternalize</code> annotation supports two parameters which will let you slightly customize its behavior:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Default value</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">excludes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Empty list</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A list of property or field names that need to be excluded from externalizing. A string consisting of a comma-separated field/property names is also allowed.
See <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/AutoExternalize.html#excludes">groovy.transform.AutoExternalize#excludes</a> for details</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.AutoExternalize

@AutoExternalize(excludes='price')
class Book {
    String isbn
    String title
    float price
}</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">includeFields</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">By default, only properties are externalized. Setting this flag to true will also clone fields.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.AutoExternalize

@AutoExternalize(includeFields=true)
class Book {
    String isbn
    String title
    protected float price
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_safer_scripting"><a class="anchor" href="#_safer_scripting"></a>2.1.6. Safer scripting</h4>
<div class="paragraph">
<p>The Groovy language makes it easy to execute user scripts at runtime (for example using <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/GroovyShell.html">groovy.lang.GroovyShell</a>),
but how do you make sure that a script won&#8217;t eat all CPU (infinite loops) or that concurrent scripts won&#8217;t slowly consume
all available threads of a thread pool? Groovy provides several annotations which are aimed towards safer scripting,
generating code which will for example allow you to interrupt execution automatically.</p>
</div>
<div class="sect4">
<h5 id="xform-ThreadInterrupt"><a class="anchor" href="#xform-ThreadInterrupt"></a><code>@groovy.transform.ThreadInterrupt</code></h5>
<div class="paragraph">
<p>One complicated situation in the JVM world is when a thread can&#8217;t be stopped. The <code>Thread#stop</code> method exists but is
deprecated (and isn&#8217;t reliable) so your only chance relies in <code>Thread#interrupt</code>. Calling the latter will set the
<code>interrupt</code> flag on the thread, but it will <strong>not</strong> stop the execution of the thread. This is problematic because it&#8217;s the
responsibility of the code executing in the thread to check the interrupt flag and properly exit. This makes sense when
you, as a developer, know that the code you are executing is meant to be run in an independent thread, but in general,
you don&#8217;t know it. It&#8217;s even worse with user scripts, who might not even know what a thread is (think of DSLs).</p>
</div>
<div class="paragraph">
<p><code>@ThreadInterrupt</code> simplifies this by adding thread interruption checks at critical places in the code:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>loops (for, while)</p>
</li>
<li>
<p>first instruction of a method</p>
</li>
<li>
<p>first instruction of a closure body</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s imagine the following user script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">while (true) {
    i++
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is an obvious infinite loop. If this code executes in its own thread, interrupting wouldn&#8217;t help: if you <code>join</code> on
the thread, then the calling code would be able to continue, but the thread would still be alive, running in background
without any ability for you to stop it, slowly causing thread starvation.</p>
</div>
<div class="paragraph">
<p>One possibility to work around this is to set up your shell this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = new CompilerConfiguration()
config.addCompilationCustomizers(
        new ASTTransformationCustomizer(ThreadInterrupt)
)
def binding = new Binding(i:0)
def shell = new GroovyShell(binding,config)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The shell is then configured to automatically apply the <code>@ThreadInterrupt</code> AST transformations on all scripts. This allows
you to execute user scripts this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def t = Thread.start {
    shell.evaluate(userCode)
}
t.join(1000) // give at most 1000ms for the script to complete
if (t.alive) {
    t.interrupt()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The transformation automatically modified user code like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">while (true) {
    if (Thread.currentThread().interrupted) {
        throw new InterruptedException('The current thread has been interrupted.')
    }
    i++
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The check which is introduced inside the loop guarantees that if the <code>interrupt</code> flag is set on the current thread, an
exception will be thrown, interrupting the execution of the thread.</p>
</div>
<div class="paragraph">
<p><code>@ThreadInterrupt</code> supports multiple options that will let you further customize the behavior of the transformation:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Default value</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">thrown</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang.InterruptedException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies the type of exception which is thrown if the thread is interrupted.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class BadException extends Exception {
    BadException(String message) { super(message) }
}

def config = new CompilerConfiguration()
config.addCompilationCustomizers(
        new ASTTransformationCustomizer(thrown:BadException, ThreadInterrupt)
)
def binding = new Binding(i:0)
def shell = new GroovyShell(this.class.classLoader,binding,config)

def userCode = """
try {
    while (true) {
        i++
    }
} catch (BadException e) {
    i = -1
}
"""

def t = Thread.start {
    shell.evaluate(userCode)
}
t.join(1000) // give at most 1s for the script to complete
assert binding.i &gt; 0
if (t.alive) {
    t.interrupt()
}
Thread.sleep(500)
assert binding.i == -1'''</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">checkOnMethodStart</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should an interruption check be inserted at the beginning of each method body. See <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/ThreadInterrupt.html">groovy.transform.ThreadInterrupt</a> for details.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ThreadInterrupt(checkOnMethodStart=false)</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">applyToAllClasses</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should the transformation be applied on all classes of the same source unit (in the same source file). See <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/ThreadInterrupt.html">groovy.transform.ThreadInterrupt</a> for details.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ThreadInterrupt(applyToAllClasses=false)
class A { ... } // interrupt checks added
class B { ... } // no interrupt checks</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">applyToAllMembers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should the transformation be applied on all members of class. See <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/ThreadInterrupt.html">groovy.transform.ThreadInterrupt</a> for details.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class A {
    @ThreadInterrupt(applyToAllMembers=false)
    void method1() { ... } // interrupt checked added
    void method2() { ... } // no interrupt checks
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="xform-TimedInterrupt"><a class="anchor" href="#xform-TimedInterrupt"></a><code>@groovy.transform.TimedInterrupt</code></h5>
<div class="paragraph">
<p>The <code>@TimedInterrupt</code> AST transformation tries to solve a slightly different problem from <a href="#xform-ThreadInterrupt"><code>@groovy.transform.ThreadInterrupt</code></a>: instead of checking the <code>interrupt</code> flag of the thread, it will automatically
throw an exception if the thread has been running for too long.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This annotation does <strong>not</strong> spawn a monitoring thread. Instead, it works in a similar manner as <code>@ThreadInterrupt</code> by placing checks at appropriate places in the code. This means that if you
have a thread blocked by I/O, it will <strong>not</strong> be interrupted.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Imagine the following user code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def fib(int n) { n&lt;2?n:fib(n-1)+fib(n-2) }

result = fib(600)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The implementation of the famous Fibonacci number computation here is far from optimized. If it is called with a high <code>n</code> value, it can take minutes to answer. With <code>@TimedInterrupt</code>, you can
choose how long a script is allowed to run. The following setup code will allow the user script to run for 1 second at max:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = new CompilerConfiguration()
config.addCompilationCustomizers(
        new ASTTransformationCustomizer(value:1, TimedInterrupt)
)
def binding = new Binding(result:0)
def shell = new GroovyShell(this.class.classLoader, binding,config)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This code is equivalent to annotating a class with <code>@TimedInterrupt</code> like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TimedInterrupt(value=1, unit=TimeUnit.SECONDS)
class MyClass {
    def fib(int n) {
        n&lt;2?n:fib(n-1)+fib(n-2)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@TimedInterrupt</code> supports multiple options that will let you further customize the behavior of the transformation:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Default value</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long.MAX_VALUE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used in combination with <code>unit</code> to specify after how long execution times out.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TimedInterrupt(value=500L, unit= TimeUnit.MILLISECONDS, applyToAllClasses = false)
class Slow {
    def fib(n) { n&lt;2?n:fib(n-1)+fib(n-2) }
}
def result
def t = Thread.start {
    result = new Slow().fib(500)
}
t.join(5000)
assert result == null
assert !t.alive</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">unit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TimeUnit.SECONDS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used in combination with <code>value</code> to specify after how long execution times out.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TimedInterrupt(value=500L, unit= TimeUnit.MILLISECONDS, applyToAllClasses = false)
class Slow {
    def fib(n) { n&lt;2?n:fib(n-1)+fib(n-2) }
}
def result
def t = Thread.start {
    result = new Slow().fib(500)
}
t.join(5000)
assert result == null
assert !t.alive</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">thrown</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.concurrent.TimeoutException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies the type of exception which is thrown if timeout is reached.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TimedInterrupt(thrown=TooLongException, applyToAllClasses = false, value=1L)
class Slow {
    def fib(n) { Thread.sleep(100); n&lt;2?n:fib(n-1)+fib(n-2) }
}
def result
def t = Thread.start {
    try {
        result = new Slow().fib(50)
    } catch (TooLongException e) {
        result = -1
    }
}
t.join(5000)
assert result == -1</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">checkOnMethodStart</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should an interruption check be inserted at the beginning of each method body. See <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/TimedInterrupt.html">groovy.transform.TimedInterrupt</a> for details.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TimedInterrupt(checkOnMethodStart=false)</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">applyToAllClasses</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should the transformation be applied on all classes of the same source unit (in the same source file). See <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/TimedInterrupt.html">groovy.transform.TimedInterrupt</a> for details.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@TimedInterrupt(applyToAllClasses=false)
class A { ... } // interrupt checks added
class B { ... } // no interrupt checks</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">applyToAllMembers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should the transformation be applied on all members of class. See <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/TimedInterrupt.html">groovy.transform.TimedInterrupt</a> for details.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class A {
    @TimedInterrupt(applyToAllMembers=false)
    void method1() { ... } // interrupt checked added
    void method2() { ... } // no interrupt checks
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>@TimedInterrupt</code> is currently not compatible with static methods!
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="xform-ConditionalInterrupt"><a class="anchor" href="#xform-ConditionalInterrupt"></a><code>@groovy.transform.ConditionalInterrupt</code></h5>
<div class="paragraph">
<p>The last annotation for safer scripting is the base annotation when you want to interrupt a script using a custom strategy. In particular, this is the annotation of choice if you
want to use resource management (limit the number of calls to an API, &#8230;&#8203;). In the following example, user code is using an infinite loop, but <code>@ConditionalInterrupt</code> will allow us
to check a quota manager and interrupt automatically the script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ConditionalInterrupt({Quotas.disallow('user')})
class UserCode {
    void doSomething() {
        int i=0
        while (true) {
            println "Consuming resources ${++i}"
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The quota checking is very basic here, but it can be any code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Quotas {
    static def quotas = [:].withDefault { 10 }
    static boolean disallow(String userName) {
        println "Checking quota for $userName"
        (quotas[userName]--)&lt;0
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can make sure <code>@ConditionalInterrupt</code> works properly using this test code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert Quotas.quotas['user'] == 10
def t = Thread.start {
    new UserCode().doSomething()
}
t.join(5000)
assert !t.alive
assert Quotas.quotas['user'] &lt; 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, in practice, it is unlikely that <code>@ConditionalInterrupt</code> will be itself added by hand on user code. It can be injected in a similar manner as the example shown in the
<a href="#xform-ThreadInterrupt">ThreadInterrupt</a> section, using the <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/control/customizers/ASTTransformationCustomizer.html">org.codehaus.groovy.control.customizers.ASTTransformationCustomizer</a> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def config = new CompilerConfiguration()
def checkExpression = new ClosureExpression(
        Parameter.EMPTY_ARRAY,
        new ExpressionStatement(
                new MethodCallExpression(new ClassExpression(ClassHelper.make(Quotas)), 'disallow', new ConstantExpression('user'))
        )
)
config.addCompilationCustomizers(
        new ASTTransformationCustomizer(value: checkExpression, ConditionalInterrupt)
)

def shell = new GroovyShell(this.class.classLoader,new Binding(),config)

def userCode = """
        int i=0
        while (true) {
            println "Consuming resources \\${++i}"
        }
"""

assert Quotas.quotas['user'] == 10
def t = Thread.start {
    shell.evaluate(userCode)
}
t.join(5000)
assert !t.alive
assert Quotas.quotas['user'] &lt; 0</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@ConditionalInterrupt</code> supports multiple options that will let you further customize the behavior of the transformation:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Default value</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">value</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The closure which will be called to check if execution is allowed. If the closure returns false, execution is allowed. If it returns true, then an exception will be thrown.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ConditionalInterrupt({ ... })</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">thrown</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang.InterruptedException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies the type of exception which is thrown if execution should be aborted.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">config.addCompilationCustomizers(
        new ASTTransformationCustomizer(thrown: QuotaExceededException,value: checkExpression, ConditionalInterrupt)
)
assert Quotas.quotas['user'] == 10
def t = Thread.start {
    try {
        shell.evaluate(userCode)
    } catch (QuotaExceededException) {
        Quotas.quotas['user'] = 'Quota exceeded'
    }
}
t.join(5000)
assert !t.alive
assert Quotas.quotas['user'] == 'Quota exceeded'</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">checkOnMethodStart</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should an interruption check be inserted at the beginning of each method body. See <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/ConditionalInterrupt.html">groovy.transform.ConditionalInterrupt</a> for details.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ConditionalInterrupt(checkOnMethodStart=false)</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">applyToAllClasses</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should the transformation be applied on all classes of the same source unit (in the same source file). See <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/ConditionalInterrupt.html">groovy.transform.ConditionalInterrupt</a> for details.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@ConditionalInterrupt(applyToAllClasses=false)
class A { ... } // interrupt checks added
class B { ... } // no interrupt checks</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">applyToAllMembers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Should the transformation be applied on all members of class. See <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/ConditionalInterrupt.html">groovy.transform.ConditionalInterrupt</a> for details.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class A {
    @ConditionalInterrupt(applyToAllMembers=false)
    void method1() { ... } // interrupt checked added
    void method2() { ... } // no interrupt checks
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_compiler_directives"><a class="anchor" href="#_compiler_directives"></a>2.1.7. Compiler directives</h4>
<div class="paragraph">
<p>This category of AST transformations groups annotations which have a direct impact on the semantics of the code, rather
than focusing on code generation. With that regards, they can be seen as compiler directives that either change the
behavior of a program at compile time or runtime.</p>
</div>
<div class="sect4">
<h5 id="xform-Field"><a class="anchor" href="#xform-Field"></a><code>@groovy.transform.Field</code></h5>
<div class="paragraph">
<p>The <code>@Field</code> annotation only makes sense in the context of a script and aims at solving a common scoping error with
scripts. The following example will for example fail at runtime:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def x

String line() {
    "="*x
}

x=3
assert "===" == line()
x=5
assert "=====" == line()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The error that is thrown may be difficult to interpret: groovy.lang.MissingPropertyException: No such property: x. The reason is that scripts are compiled
to classes and the script body is itself compiled as a single <em>run()</em> method. Methods which are defined in the scripts are independent, so the code above is
equivalent to this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MyScript extends Script {

    String line() {
        "="*x
    }

    public def run() {
        def x
        x=3
        assert "===" == line()
        x=5
        assert "=====" == line()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>So <code>def x</code> is effectively interpreted as a local variable, outside of the scope of the <code>line</code> method. The <code>@Field</code> AST transformation aims at fixing this
by changing the scope of the variable to a field of the enclosing script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Field def x

String line() {
    "="*x
}

x=3
assert "===" == line()
x=5
assert "=====" == line()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The resulting, equivalent, code is now:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MyScript extends Script {

    def x

    String line() {
        "="*x
    }

    public def run() {
        x=3
        assert "===" == line()
        x=5
        assert "=====" == line()
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xform-PackageScope"><a class="anchor" href="#xform-PackageScope"></a><code>@groovy.transform.PackageScope</code></h5>
<div class="paragraph">
<p>By default, Groovy visibility rules imply that if you create a field without specifying a modifier, then the field is interpreted as a property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name // this is a property
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Should you want to create a package private field instead of a property (private field+getter/setter), then annotate your field with <code>@PackageScope</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    @PackageScope String name // not a property anymore
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@PackageScope</code> annotation can also be used for classes, methods and constructors. In addition, by specifying a list
of <code>PackageScopeTarget</code> values as the annotation attribute at the class level, all members within that class that don&#8217;t
have an explicit modifier and match the provided <code>PackageScopeTarget</code> will remain package protected. For example to apply
to fields within a class use the following annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import static groovy.transform.PackageScopeTarget.FIELDS
@PackageScope(FIELDS)
class Person {
  String name     // not a property, package protected
  Date dob        // not a property, package protected
  private int age // explicit modifier, so won't be touched
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@PackageScope</code> annotation is seldom used as part of normal Groovy conventions but is sometimes useful
for factory methods that should be visible internally within a package or for methods or constructors provided
for testing purposes, or when integrating with third-party libraries which require such visibility conventions.</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-AutoFinal"><a class="anchor" href="#xform-AutoFinal"></a><code>@groovy.transform.AutoFinal</code></h5>
<div class="paragraph">
<p>The <code>@AutoFinal</code> annotation instructs the compiler to automatically insert the final modifier
in numerous places within the annotated node. If applied on a method (or constructor), the parameters
for that method (or constructor) will be marked as final. If applied on a class definition, the same
treatment will occur for all declared methods and constructors within that class.</p>
</div>
<div class="paragraph">
<p>It is often considered bad practice to reassign parameters of a method or constructor with its body.
By adding the final modifier to all parameter declarations you can avoid this practice entirely.
Some programmers feel that adding final everywhere increases the amount of boilerplate code and makes the
method signatures somewhat noisy. An alternative might instead be to use a code review process or apply
a <a href="http://codenarc.org">codenarc</a> <a href="https://codenarc.github.io/CodeNarc/codenarc-rules-convention.html#parameterreassignment-rule">rule</a>
to give warnings if that practice is observed but these alternatives might lead to delayed feedback during
quality checking rather than within the IDE or during compilation. The <code>@AutoFinal</code> annotation aims to
maximise compiler/IDE feedback while retaining succinct code with minimum boilerplate noise.</p>
</div>
<div class="paragraph">
<p>The following example illustrates applying the annotation at the class level:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.AutoFinal

@AutoFinal
class Person {
    private String first, last

    Person(String first, String last) {
        this.first = first
        this.last = last
    }

    String fullName(String separator) {
        "$first$separator$last"
    }

    String greeting(String salutation) {
        "$salutation, $first"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the two parameters for the constructor and the single parameter for
both the <code>fullname</code> and <code>greeting</code> methods will be final. Attempts to modify those parameters within the
constructor or method bodies will be flagged by the compiler.</p>
</div>
<div class="paragraph">
<p>The following example illustrates applying the annotation at the method level:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Calc {
    @AutoFinal
    int add(int a, int b) { a + b }

    int mult(int a, int b) { a * b }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the <code>add</code> method will have final parameters but the <code>mult</code> method will remain unchanged.</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-AnnotationCollector"><a class="anchor" href="#xform-AnnotationCollector"></a><code>@groovy.transform.AnnotationCollector</code></h5>
<div class="paragraph">
<p><code>@AnnotationCollector</code> allows the creation of meta-annotations, which are described in a <a href="core-object-orientation.html#_meta_annotations">dedicated section</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-TypeChecked"><a class="anchor" href="#xform-TypeChecked"></a><code>@groovy.transform.TypeChecked</code></h5>
<div class="paragraph">
<p><code>@TypeChecked</code> activates compile-time type checking on your Groovy code. See <a href="core-semantics.html#static-type-checking">section on type checking</a> for details.</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-CompileStatic"><a class="anchor" href="#xform-CompileStatic"></a><code>@groovy.transform.CompileStatic</code></h5>
<div class="paragraph">
<p><code>@CompileStatic</code> activates static compilation on your Groovy code. See <a href="core-semantics.html#static-type-checking">section on type checking</a> for details.</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-CompileDynamic"><a class="anchor" href="#xform-CompileDynamic"></a><code>@groovy.transform.CompileDynamic</code></h5>
<div class="paragraph">
<p><code>@CompileDynamic</code> disables static compilation on parts of your Groovy code. See <a href="core-semantics.html#static-type-checking">section on type checking</a> for details.</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-DelegatesTo"><a class="anchor" href="#xform-DelegatesTo"></a><code>@groovy.lang.DelegatesTo</code></h5>
<div class="paragraph">
<p><code>@DelegatesTo</code> is not, technically speaking, an AST transformation. It is aimed at documenting code and helping the compiler in case you are
using <a href="#xform-TypeChecked">type checking</a> or <a href="#xform-CompileStatic">static compilation</a>. The annotation is described thoroughly in the
<a href="core-domain-specific-languages.html#section-delegatesto">DSL section</a> of this guide.</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-SelfType"><a class="anchor" href="#xform-SelfType"></a><code>@groovy.transform.SelfType</code></h5>
<div class="paragraph">
<p><code>@SelfType</code> is not an AST transformation but rather a marker interface used
with traits. See the <a href="core-traits.html#traits-selftype">traits documentation</a> for further details.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_swing_patterns"><a class="anchor" href="#_swing_patterns"></a>2.1.8. Swing patterns</h4>
<div class="sect4">
<h5 id="xform-Bindable"><a class="anchor" href="#xform-Bindable"></a><code>@groovy.beans.Bindable</code></h5>
<div class="paragraph">
<p><code>@Bindable</code> is an AST transformation that transforms a regular property into a bound property (according to the <a href="http://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/">JavaBeans specification</a>).
The <code>@Bindable</code> annotation can be placed on a property or a class. To convert all properties of a class into bound properties, on can annotate the class like in this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.beans.Bindable

@Bindable
class Person {
    String name
    int age
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is equivalent to writing this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import java.beans.PropertyChangeListener
import java.beans.PropertyChangeSupport

class Person {
    final private PropertyChangeSupport this$propertyChangeSupport

    String name
    int age

    public void addPropertyChangeListener(PropertyChangeListener listener) {
        this$propertyChangeSupport.addPropertyChangeListener(listener)
    }

    public void addPropertyChangeListener(String name, PropertyChangeListener listener) {
        this$propertyChangeSupport.addPropertyChangeListener(name, listener)
    }

    public void removePropertyChangeListener(PropertyChangeListener listener) {
        this$propertyChangeSupport.removePropertyChangeListener(listener)
    }

    public void removePropertyChangeListener(String name, PropertyChangeListener listener) {
        this$propertyChangeSupport.removePropertyChangeListener(name, listener)
    }

    public void firePropertyChange(String name, Object oldValue, Object newValue) {
        this$propertyChangeSupport.firePropertyChange(name, oldValue, newValue)
    }

    public PropertyChangeListener[] getPropertyChangeListeners() {
        return this$propertyChangeSupport.getPropertyChangeListeners()
    }

    public PropertyChangeListener[] getPropertyChangeListeners(String name) {
        return this$propertyChangeSupport.getPropertyChangeListeners(name)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@Bindable</code> therefore removes a lot of boilerplate from your class, dramatically increasing readability. If the annotation is put on a single property, only that property is bound:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.beans.Bindable

class Person {
    String name
    @Bindable int age
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xform-ListenerList"><a class="anchor" href="#xform-ListenerList"></a><code>@groovy.beans.ListenerList</code></h5>
<div class="paragraph">
<p>The <code>@ListenerList</code> AST transformation generates code for adding, removing and getting the list of listeners to a class, just by annotating a collection property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import java.awt.event.ActionListener
import groovy.beans.ListenerList

class Component {
    @ListenerList
    List&lt;ActionListener&gt; listeners;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The transform will generate the appropriate add/remove methods based on the generic type of the list. In addition, it will also create <code>fireXXX</code> methods based on the public methods declared on the class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import java.awt.event.ActionEvent
import java.awt.event.ActionListener as ActionListener
import groovy.beans.ListenerList as ListenerList

public class Component {

    @ListenerList
    private List&lt;ActionListener&gt; listeners

    public void addActionListener(ActionListener listener) {
        if ( listener == null) {
            return
        }
        if ( listeners == null) {
            listeners = []
        }
        listeners.add(listener)
    }

    public void removeActionListener(ActionListener listener) {
        if ( listener == null) {
            return
        }
        if ( listeners == null) {
            listeners = []
        }
        listeners.remove(listener)
    }

    public ActionListener[] getActionListeners() {
        Object __result = []
        if ( listeners != null) {
            __result.addAll(listeners)
        }
        return (( __result ) as ActionListener[])
    }

    public void fireActionPerformed(ActionEvent param0) {
        if ( listeners != null) {
            ArrayList&lt;ActionListener&gt; __list = new ArrayList&lt;ActionListener&gt;(listeners)
            for (def listener : __list ) {
                listener.actionPerformed(param0)
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@Bindable</code> supports multiple options that will let you further customize the behavior of the transformation:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Default value</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Generic type name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">By default, the suffix which will be appended to add/remove/&#8230;&#8203; methods is the simple class name of the generic type of the list.</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Component {
    @ListenerList(name='item')
    List&lt;ActionListener&gt; listeners;
}</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">synchronize</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If set to true, generated methods will be synchronized</p></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Component {
    @ListenerList(synchronize = true)
    List&lt;ActionListener&gt; listeners;
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="xform-Vetoable"><a class="anchor" href="#xform-Vetoable"></a><code>@groovy.beans.Vetoable</code></h5>
<div class="paragraph">
<p>The <code>@Vetoable</code> annotation works in a similar manner to <code>@Bindable</code> but generates constrained property according to the JavaBeans specification, instead of bound properties. The annotation
can be placed on a class, meaning that all properties will be converted to constrained properties, or on a single property. For example, annotating this class with <code>@Vetoable</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.beans.Vetoable

import java.beans.PropertyVetoException
import java.beans.VetoableChangeListener

@Vetoable
class Person {
    String name
    int age
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to writing this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public class Person {

    private String name
    private int age
    final private java.beans.VetoableChangeSupport this$vetoableChangeSupport

    public void addVetoableChangeListener(VetoableChangeListener listener) {
        this$vetoableChangeSupport.addVetoableChangeListener(listener)
    }

    public void addVetoableChangeListener(String name, VetoableChangeListener listener) {
        this$vetoableChangeSupport.addVetoableChangeListener(name, listener)
    }

    public void removeVetoableChangeListener(VetoableChangeListener listener) {
        this$vetoableChangeSupport.removeVetoableChangeListener(listener)
    }

    public void removeVetoableChangeListener(String name, VetoableChangeListener listener) {
        this$vetoableChangeSupport.removeVetoableChangeListener(name, listener)
    }

    public void fireVetoableChange(String name, Object oldValue, Object newValue) throws PropertyVetoException {
        this$vetoableChangeSupport.fireVetoableChange(name, oldValue, newValue)
    }

    public VetoableChangeListener[] getVetoableChangeListeners() {
        return this$vetoableChangeSupport.getVetoableChangeListeners()
    }

    public VetoableChangeListener[] getVetoableChangeListeners(String name) {
        return this$vetoableChangeSupport.getVetoableChangeListeners(name)
    }

    public void setName(String value) throws PropertyVetoException {
        this.fireVetoableChange('name', name, value)
        name = value
    }

    public void setAge(int value) throws PropertyVetoException {
        this.fireVetoableChange('age', age, value)
        age = value
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the annotation is put on a single property, only that property is made vetoable:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.beans.Vetoable

class Person {
    String name
    @Vetoable int age
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_test_assistance"><a class="anchor" href="#_test_assistance"></a>2.1.9. Test assistance</h4>
<div class="sect4">
<h5 id="xform-NotYetImplemented"><a class="anchor" href="#xform-NotYetImplemented"></a><code>@groovy.test.NotYetImplemented</code></h5>
<div class="paragraph">
<p><code>@NotYetImplemented</code> is used to invert the result of a JUnit 3/4 test case. It is in particular useful if a feature is not yet implemented but the test is. In that case, it is expected
that the test fails. Marking it with <code>@NotYetImplemented</code> will inverse the result of the test, like in this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.test.GroovyTestCase
import groovy.test.NotYetImplemented

class Maths {
    static int fib(int n) {
        // todo: implement later
    }
}

class MathsTest extends GroovyTestCase {
    @NotYetImplemented
    void testFib() {
        def dataTable = [
                1:1,
                2:1,
                3:2,
                4:3,
                5:5,
                6:8,
                7:13
        ]
        dataTable.each { i, r -&gt;
            assert Maths.fib(i) == r
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another advantage of using this technique is that you can write test cases for bugs before knowing how to fix them. If some time in the future, a modification in the code fixes a bug by side effect,
you&#8217;ll be notified because a test which was expected to fail passed.</p>
</div>
</div>
<div class="sect4">
<h5 id="xform-ASTTest"><a class="anchor" href="#xform-ASTTest"></a><code>@groovy.transform.ASTTest</code></h5>
<div class="paragraph">
<p><code>@ASTTest</code> is a special AST transformation meant to help debugging other AST transformations or the Groovy compiler itself. It will let the developer "explore" the AST during compilation and
perform assertions on the AST rather than on the result of compilation. This means that this AST transformations gives access to the AST before the bytecode is produced. <code>@ASTTest</code> can be
placed on any annotable node and requires two parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>phase</em>: sets at which phase at which <code>@ASTTest</code> will be triggered. The test code will work on the AST tree at the end of this phase.</p>
</li>
<li>
<p><em>value</em>: the code which will be executed once the phase is reached, on the annotated node</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Compile phase has to be chosen from one of <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/control/CompilePhase.html">org.codehaus.groovy.control.CompilePhase</a> . However, since it is not possible to annotate a node twice with the same annotation, you will
not be able to use <code>@ASTTest</code> on the same node at two distinct compile phases.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>value</code> is a closure expression which has access to a special variable <code>node</code> corresponding to the annotated node, and a helper <code>lookup</code> method which will be discussed <a href="#asttest-lookup">here</a>.
For example, you can annotate a class node like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.ASTTest
import org.codehaus.groovy.ast.ClassNode
import static org.codehaus.groovy.control.CompilePhase.*

@ASTTest(phase=CONVERSION, value={   <i class="conum" data-value="1"></i><b>(1)</b>
    assert node instanceof ClassNode <i class="conum" data-value="2"></i><b>(2)</b>
    assert node.name == 'Person'     <i class="conum" data-value="3"></i><b>(3)</b>
})
class Person {

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>we&#8217;re checking the state of the Abstract Syntax Tree after the CONVERSION phase</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>node refers to the AST node which is annotated by @ASTTest</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>it can be used to perform assertions at compile time</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>One interesting feature of <code>@ASTTest</code> is that if an assertion fails, then <strong>compilation will fail</strong>. Now imagine that we want to check the behavior of an AST transformation at compile time.
We will take <code>@PackageScope</code> here, and we will want to verify that a property annotated with <code>@PackageScope</code> becomes a package private field. For this, we have to know at which phase the
transform runs, which can be found in <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/transform/PackageScopeASTTransformation.html">org.codehaus.groovy.transform.PackageScopeASTTransformation</a> : semantic analysis. Then a test can be written like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.ASTTest
import groovy.transform.PackageScope

import static org.codehaus.groovy.control.CompilePhase.*

@ASTTest(phase=SEMANTIC_ANALYSIS, value= {
    def nameNode = node.properties.find { it.name == 'name' }
    def ageNode = node.properties.find { it.name == 'age' }
    assert nameNode
    assert ageNode == null // shouldn't be a property anymore
    def ageField = node.getDeclaredField 'age'
    assert ageField.modifiers == 0
})
class Person {
    String name
    @PackageScope int age
}</code></pre>
</div>
</div>
<div id="asttest-lookup" class="paragraph">
<p>The <code>@ASTTest</code> annotation can only be placed wherever the grammar allows it. Sometimes, you would like to test the contents of an AST node which is not annotable. In this case,
<code>@ASTTest</code> provides a convenient <code>lookup</code> method which will search the AST for nodes which are labelled with a special token:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def list = lookup('anchor') <i class="conum" data-value="1"></i><b>(1)</b>
Statement stmt = list[0] <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>returns the list of AST nodes which label is 'anchor'</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>it is always necessary to choose which element to process since lookup always returns a list</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Imagine, for example, that you want to test the declared type of a for loop variable. Then you can do it like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.ASTTest
import groovy.transform.PackageScope
import org.codehaus.groovy.ast.ClassHelper
import org.codehaus.groovy.ast.expr.DeclarationExpression
import org.codehaus.groovy.ast.stmt.ForStatement

import static org.codehaus.groovy.control.CompilePhase.*

class Something {
    @ASTTest(phase=SEMANTIC_ANALYSIS, value= {
        def forLoop = lookup('anchor')[0]
        assert forLoop instanceof ForStatement
        def decl = forLoop.collectionExpression.expressions[0]
        assert decl instanceof DeclarationExpression
        assert decl.variableExpression.name == 'i'
        assert decl.variableExpression.originType == ClassHelper.int_TYPE
    })
    void someMethod() {
        int x = 1;
        int y = 10;
        anchor: for (int i=0; i&lt;x+y; i++) {
            println "$i"
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@ASTTest</code> also exposes those variables inside the test closure:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>node</code> corresponds to the annotated node, as usual</p>
</li>
<li>
<p><code>compilationUnit</code> gives access to the current <code>org.codehaus.groovy.control.CompilationUnit</code></p>
</li>
<li>
<p><code>compilePhase</code> returns the current compile phase (<code>org.codehaus.groovy.control.CompilePhase</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The latter is interesting if you don&#8217;t specify the <code>phase</code> attribute. In that case, the closure will be executed after
each compile phase after (and including) <code>SEMANTIC_ANALYSIS</code>. The context of the transformation is kept after each phase,
giving you a chance to check what changed between two phases.</p>
</div>
<div class="paragraph">
<p>As an example, here is how you could dump the list of AST transformations registered on a class node:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.ASTTest
import groovy.transform.CompileStatic
import groovy.transform.Immutable
import org.codehaus.groovy.ast.ClassNode
import org.codehaus.groovy.control.CompilePhase

@ASTTest(value={
    System.err.println "Compile phase: $compilePhase"
    ClassNode cn = node
    System.err.println "Global AST xforms: ${compilationUnit?.ASTTransformationsContext?.globalTransformNames}"
    CompilePhase.values().each {
        def transforms = cn.getTransforms(it)
        if (transforms) {
            System.err.println "Ast xforms for phase $it:"
            transforms.each { map -&gt;
                System.err.println(map)
            }
        }
    }
})
@CompileStatic
@Immutable
class Foo {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And here is how you can memorize variables for testing between two phases:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.ASTTest
import groovy.transform.ToString
import org.codehaus.groovy.ast.ClassNode
import org.codehaus.groovy.control.CompilePhase

@ASTTest(value={
    if (compilePhase==CompilePhase.INSTRUCTION_SELECTION) {             <i class="conum" data-value="1"></i><b>(1)</b>
        println "toString() was added at phase: ${added}"
        assert added == CompilePhase.CANONICALIZATION                   <i class="conum" data-value="2"></i><b>(2)</b>
    } else {
        if (node.getDeclaredMethods('toString') &amp;&amp; added==null) {       <i class="conum" data-value="3"></i><b>(3)</b>
            added = compilePhase                                        <i class="conum" data-value="4"></i><b>(4)</b>
        }
    }
})
@ToString
class Foo {
    String name
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>if the current compile phase is instruction selection</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>then we want to make sure <code>toString</code> was added at <code>CANONICALIZATION</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>otherwise, if <code>toString</code> exists and that the variable from the context, <code>added</code> is null</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>then it means that this compile phase is the one where <code>toString</code> was added</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_grape_handling"><a class="anchor" href="#_grape_handling"></a>2.1.10. Grape handling</h4>
<div class="sect4">
<h5 id="xform-Grab"><a class="anchor" href="#xform-Grab"></a><code>@groovy.lang.Grab</code></h5>

</div>
<div class="sect4">
<h5 id="xform-GrabConfig"><a class="anchor" href="#xform-GrabConfig"></a><code>@groovy.lang.GrabConfig</code></h5>

</div>
<div class="sect4">
<h5 id="xform-GrabExclude"><a class="anchor" href="#xform-GrabExclude"></a><code>@groovy.lang.GrabExclude</code></h5>

</div>
<div class="sect4">
<h5 id="xform-GrabResolver"><a class="anchor" href="#xform-GrabResolver"></a><code>@groovy.lang.GrabResolver</code></h5>

</div>
<div class="sect4">
<h5 id="xform-Grapes"><a class="anchor" href="#xform-Grapes"></a><code>@groovy.lang.Grapes</code></h5>
<div class="paragraph">
<p><code>Grape</code> is a dependency management engine embedded into Groovy, relying on several annotations which are described
thoroughly in this <a href="grape.html#section-grape">section of the guide</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="developing-ast-xforms"><a class="anchor" href="#developing-ast-xforms"></a>2.2. Developing AST transformations</h3>
<div class="paragraph">
<p>There are two kinds of transformations: global and local transformations.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#transforms-global">Global transformations</a> are applied to by the compiler on the code being compiled,
wherever the transformation apply. Compiled classes that implement global transformations
are in a JAR added to the classpath of the compiler and contain service locator file
<code>META-INF/services/org.codehaus.groovy.transform.ASTTransformation</code> with a line with the name of the
transformation class. The transformation class must have a no-args constructor and implement the
<code>org.codehaus.groovy.transform.ASTTransformation</code> interface.
It will be run against <strong>every source in the compilation</strong>, so be sure to not create transformations which
scan all the AST in an expansive and time-consuming manner, to keep the compiler fast.</p>
</li>
<li>
<p><a href="#transforms-local">Local transformations</a> are transformations applied locally by annotating code elements you want to
transform. For this, we reuse the annotation notation, and those annotations should implement
<code>org.codehaus.groovy.transform.ASTTransformation</code>. The compiler will discover them and apply the
transformation on these code elements.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_compilation_phases_guide"><a class="anchor" href="#_compilation_phases_guide"></a>2.2.1. Compilation phases guide</h4>
<div class="paragraph">
<p>Groovy AST transformations must be performed in one of the nine defined
compilation phases (<a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/control/CompilePhase.html">org.codehaus.groovy.control.CompilePhase</a>).</p>
</div>
<div class="paragraph">
<p>Global transformations may be applied in any phase, but local
transformations may only be applied in the semantic analysis phase or
later. Briefly, the compiler phases are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Initialization</em>: source files are opened and environment configured</p>
</li>
<li>
<p><em>Parsing</em>: the grammar is used to to produce tree of tokens representing
the source code</p>
</li>
<li>
<p><em>Conversion</em>: An abstract syntax tree (AST) is created from token trees.</p>
</li>
<li>
<p><em>Semantic Analysis</em>: Performs consistency and validity checks that the
grammar can’t check for, and resolves classes.</p>
</li>
<li>
<p><em>Canonicalization</em>: Complete building the AST</p>
</li>
<li>
<p><em>Instruction Selection</em>: instruction set is chosen, for example Java 6 or Java 7 bytecode level</p>
</li>
<li>
<p><em>Class Generation</em>: creates the bytecode of the class in memory</p>
</li>
<li>
<p><em>Output</em>: write the binary output to the file system</p>
</li>
<li>
<p><em>Finalization</em>: Perform any last cleanup</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Generally speaking, there is more type information available later in
the phases. If your transformation is concerned with reading the AST,
then a later phase where information is more plentiful might be a good
choice. If your transformation is concerned with writing AST, then an
earlier phase where the tree is more sparse might be more convenient.</p>
</div>
</div>
<div class="sect3">
<h4 id="transforms-local"><a class="anchor" href="#transforms-local"></a>2.2.2. Local transformations</h4>
<div class="paragraph">
<p>Local AST transformations are relative to the context they are applied to. In
most cases, the context is defined by an annotation that will define the scope
of the transform. For example, annotating a field would mean that the transformation
<em>applies to</em> the field, while annotating the class would mean that the transformation
<em>applies to</em> the whole class.</p>
</div>
<div class="paragraph">
<p>As a naive and simple example, consider wanting to write a <code>@WithLogging</code>
transformation that would add console messages at the start and end of a
method invocation. So the following "Hello World" example would
actually print "Hello World" along with a start and stop message:</p>
</div>
<div class="listingblock">
<div class="title">Poor man&#8217;s aspect oriented programming</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@WithLogging
def greet() {
    println "Hello World"
}

greet()</code></pre>
</div>
</div>
<div class="paragraph">
<p>A local AST transformation is an easy way to do this. It requires two things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a definition of the <code>@WithLogging</code> annotation</p>
</li>
<li>
<p>an implementation of <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/transform/ASTTransformation.html">org.codehaus.groovy.transform.ASTTransformation</a> that adds the logging
expressions to the method</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An <code>ASTTransformation</code> is a callback that gives you access to the
<a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/control/SourceUnit.html">org.codehaus.groovy.control.SourceUnit</a>,
through which you can get a reference to the
<a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/ast/ModuleNode.html">org.codehaus.groovy.ast.ModuleNode</a> (AST).</p>
</div>
<div class="paragraph">
<p>The AST (Abstract Syntax Tree) is a tree structure consisting mostly of
<a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/ast/expr/Expression.html">org.codehaus.groovy.ast.expr.Expression</a> (expressions) or
<a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/ast/expr/Statement.html">org.codehaus.groovy.ast.expr.Statement</a> (statements). An easy way to
learn about the AST is to explore it in a debugger. Once you have the AST,
you can analyze it to find out information about the code or rewrite it to add
new functionality.</p>
</div>
<div class="paragraph">
<p>The local transformation annotation is the simple part. Here is the
<code>@WithLogging</code> one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import org.codehaus.groovy.transform.GroovyASTTransformationClass

import java.lang.annotation.ElementType
import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy
import java.lang.annotation.Target

@Retention(RetentionPolicy.SOURCE)
@Target([ElementType.METHOD])
@GroovyASTTransformationClass(["gep.WithLoggingASTTransformation"])
public @interface WithLogging {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The annotation retention can be <code>SOURCE</code> because you won’t need the annotation
past that. The element type here is <code>METHOD</code>, the <code>@WithLogging</code> because the annotation
applies to methods.</p>
</div>
<div class="paragraph">
<p>But the most important part is the
<code>@GroovyASTTransformationClass</code> annotation. This links the <code>@WithLogging</code>
annotation to the <code>ASTTransformation</code> class you will write.
<code>gep.WithLoggingASTTransformation</code> is the fully qualified class name of the
<code>ASTTransformation</code> we are going to write. This line wires the annotation to the transformation.</p>
</div>
<div class="paragraph">
<p>With this in place, the Groovy compiler is going to invoke
<code>gep.WithLoggingASTTransformation</code> every time an <code>@WithLogging</code> is found in a
source unit. Any breakpoint set within <code>LoggingASTTransformation</code> will now
be hit within the IDE when running the sample script.</p>
</div>
<div class="paragraph">
<p>The <code>ASTTransformation</code> class is a little more complex. Here is the
very simple, and very naive, transformation to add a method start and
stop message for <code>@WithLogging</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@CompileStatic                                                                  <i class="conum" data-value="1"></i><b>(1)</b>
@GroovyASTTransformation(phase=CompilePhase.SEMANTIC_ANALYSIS)                  <i class="conum" data-value="2"></i><b>(2)</b>
class WithLoggingASTTransformation implements ASTTransformation {               <i class="conum" data-value="3"></i><b>(3)</b>

    @Override
    void visit(ASTNode[] nodes, SourceUnit sourceUnit) {                        <i class="conum" data-value="4"></i><b>(4)</b>
        MethodNode method = (MethodNode) nodes[1]                               <i class="conum" data-value="5"></i><b>(5)</b>

        def startMessage = createPrintlnAst("Starting $method.name")            <i class="conum" data-value="6"></i><b>(6)</b>
        def endMessage = createPrintlnAst("Ending $method.name")                <i class="conum" data-value="7"></i><b>(7)</b>

        def existingStatements = ((BlockStatement)method.code).statements       <i class="conum" data-value="8"></i><b>(8)</b>
        existingStatements.add(0, startMessage)                                 <i class="conum" data-value="9"></i><b>(9)</b>
        existingStatements.add(endMessage)                                      <i class="conum" data-value="10"></i><b>(10)</b>

    }

    private static Statement createPrintlnAst(String message) {                 <i class="conum" data-value="11"></i><b>(11)</b>
        new ExpressionStatement(
            new MethodCallExpression(
                new VariableExpression("this"),
                new ConstantExpression("println"),
                new ArgumentListExpression(
                    new ConstantExpression(message)
                )
            )
        )
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>even if not mandatory, if you write an AST transformation in Groovy, it is highly recommended to use <code>CompileStatic</code>
because it will improve performance of the compiler.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>annotate with <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/transform/GroovyASTTransformation.html">org.codehaus.groovy.transform.GroovyASTTransformation</a> to tell at which compilation phase the
transform needs to run. Here, it&#8217;s at the <em>semantic analysis</em> phase.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>implement the <code>ASTTransformation</code> interface</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>which only has a single <code>visit</code> method</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>the <code>nodes</code> parameter is a 2 AST node array, for which the first one is the annotation node (<code>@WithLogging</code>) and
the second one is the annotated node (the method node)</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>create a statement that will print a message when we enter the method</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>create a statement that will print a message when we exit the method</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>get the method body, which in this case is a <code>BlockStatement</code></td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>add the enter method message before the first statement of existing code</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>append the exit method message after the last statement of existing code</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>creates an <code>ExpressionStatement</code> wrapping a <code>MethodCallExpression</code> corresponding to <code>this.println("message")</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is important to notice that for the brevity of this example, we didn&#8217;t make the necessary checks, such as checking
that the annotated node is really a <code>MethodNode</code>, or that the method body is an instance of <code>BlockStatement</code>. This
exercise is left to the reader.</p>
</div>
<div class="paragraph">
<p>Note the creation of the new println statements in the
<code>createPrintlnAst(String)</code> method. Creating AST for code is not always
simple. In this case we need to construct a new method call, passing in
the receiver/variable, the name of the method, and an argument list.
When creating AST, it might be helpful to write the code you’re trying
to create in a Groovy file and then inspect the AST of that code in the
debugger to learn what to create. Then write a function like
<code>createPrintlnAst</code> using what you learned through the debugger.</p>
</div>
<div class="paragraph">
<p>In the end:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@WithLogging
def greet() {
    println "Hello World"
}

greet()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Produces:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Starting greet
Hello World
Ending greet</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is important to note that an AST transformation participates directly in the compilation process. A common
error by beginners is to have the AST transformation code in the same source tree as a class that uses the transformation.
Being in the same source tree in general means that they are compiled at the same time. Since the transformation itself
is going to be compiled in phases and that each compile phase processes all files of the same source unit before going
to the next one, there&#8217;s a direct consequence: the transformation will not be compiled before the class that uses it! In
conclusion, AST transformations need to be precompiled before you can use them. In general, it is as easy as having them
in a separate source tree.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="transforms-global"><a class="anchor" href="#transforms-global"></a>2.2.3. Global transformations</h4>
<div class="paragraph">
<p>Global AST transformation are similar to local one with a major difference: they do not need an annotation, meaning that
they are applied <em>globally</em>, that is to say on each class being compiled. It is therefore very important to limit their
use to last resort, because it can have a significant impact on the compiler performance.</p>
</div>
<div class="paragraph">
<p>Following the example of the <a href="#transform-local">local AST transformation</a>, imagine that we would like to trace all
methods, and not only those which are annotated with <code>@WithLogging</code>. Basically, we need this code to behave the same
as the one annotated with <code>@WithLogging</code> before:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def greet() {
    println "Hello World"
}

greet()</code></pre>
</div>
</div>
<div class="paragraph">
<p>To make this work, there are two steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>create the <code>org.codehaus.groovy.transform.ASTTransformation</code> descriptor inside the <code>META-INF/services</code> directory</p>
</li>
<li>
<p>create the <code>ASTTransformation</code> implementation</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The descriptor file is required and must be found on classpath. It will contain a single line:</p>
</div>
<div class="listingblock">
<div class="title">META-INF/services/org.codehaus.groovy.transform.ASTTransformation</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">gep.WithLoggingASTTransformation</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code for the transformation looks similar to the local case, but instead of using the <code>ASTNode[]</code> parameter, we need
to use the <code>SourceUnit</code> instead:</p>
</div>
<div class="listingblock">
<div class="title">gep/WithLoggingASTTransformation.groovy</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@CompileStatic                                                                  <i class="conum" data-value="1"></i><b>(1)</b>
@GroovyASTTransformation(phase=CompilePhase.SEMANTIC_ANALYSIS)                  <i class="conum" data-value="2"></i><b>(2)</b>
class WithLoggingASTTransformation implements ASTTransformation {               <i class="conum" data-value="3"></i><b>(3)</b>

    @Override
    void visit(ASTNode[] nodes, SourceUnit sourceUnit) {                        <i class="conum" data-value="4"></i><b>(4)</b>
        def methods = sourceUnit.AST.methods                                    <i class="conum" data-value="5"></i><b>(5)</b>
        methods.each { method -&gt;                                                <i class="conum" data-value="6"></i><b>(6)</b>
            def startMessage = createPrintlnAst("Starting $method.name")        <i class="conum" data-value="7"></i><b>(7)</b>
            def endMessage = createPrintlnAst("Ending $method.name")            <i class="conum" data-value="8"></i><b>(8)</b>

            def existingStatements = ((BlockStatement)method.code).statements   <i class="conum" data-value="9"></i><b>(9)</b>
            existingStatements.add(0, startMessage)                             <i class="conum" data-value="10"></i><b>(10)</b>
            existingStatements.add(endMessage)                                  <i class="conum" data-value="11"></i><b>(11)</b>
        }
    }

    private static Statement createPrintlnAst(String message) {                 <i class="conum" data-value="12"></i><b>(12)</b>
        new ExpressionStatement(
            new MethodCallExpression(
                new VariableExpression("this"),
                new ConstantExpression("println"),
                new ArgumentListExpression(
                    new ConstantExpression(message)
                )
            )
        )
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>even if not mandatory, if you write an AST transformation in Groovy, it is highly recommended to use <code>CompileStatic</code>
because it will improve performance of the compiler.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>annotate with <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/transform/GroovyASTTransformation.html">org.codehaus.groovy.transform.GroovyASTTransformation</a> to tell at which compilation phase the
transform needs to run. Here, it&#8217;s at the <em>semantic analysis</em> phase.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>implement the <code>ASTTransformation</code> interface</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>which only has a single <code>visit</code> method</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>the <code>sourceUnit</code> parameter gives access to the source being compiled, so we get the AST of the current source
and retrieve the list of methods from this file</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>we iterate on each method from the source file</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>create a statement that will print a message when we enter the method</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>create a statement that will print a message when we exit the method</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>get the method body, which in this case is a <code>BlockStatement</code></td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>add the enter method message before the first statement of existing code</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>append the exit method message after the last statement of existing code</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>creates an <code>ExpressionStatement</code> wrapping a <code>MethodCallExpression</code> corresponding to <code>this.println("message")</code></td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_ast_api_guide"><a class="anchor" href="#_ast_api_guide"></a>2.2.4. AST API guide</h4>
<div class="sect4">
<h5 id="_abstractasttransformation"><a class="anchor" href="#_abstractasttransformation"></a>AbstractASTTransformation</h5>
<div class="paragraph">
<p>While you have seen that you can directly implement the <code>ASTTransformation</code> interface, in almost all cases you will not
do this but extend the <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/transform/AbstractASTTransformation.html">org.codehaus.groovy.transform.AbstractASTTransformation</a> class. This class provides several
utility methods that make AST transformations easier to write. Almost all AST transformations included in Groovy
extend this class.</p>
</div>
</div>
<div class="sect4">
<h5 id="_classcodeexpressiontransformer"><a class="anchor" href="#_classcodeexpressiontransformer"></a>ClassCodeExpressionTransformer</h5>
<div class="paragraph">
<p>It is a common use case to be able to transform an expression into another. Groovy provides a class which makes it
very easy to do this: <a href="https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/ast/ClassCodeExpressionTransformer.html">org.codehaus.groovy.ast.ClassCodeExpressionTransformer</a></p>
</div>
<div class="paragraph">
<p>To illustrate this, let&#8217;s create a <code>@Shout</code> transformation that will transform all <code>String</code> constants in method call
arguments into their uppercase version. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Shout
def greet() {
    println "Hello World"
}

greet()</code></pre>
</div>
</div>
<div class="paragraph">
<p>should print:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>HELLO WORLD</pre>
</div>
</div>
<div class="paragraph">
<p>Then the code for the transformation can use the <code>ClassCodeExpressionTransformer</code> to make this easier:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@CompileStatic
@GroovyASTTransformation(phase=CompilePhase.SEMANTIC_ANALYSIS)
class ShoutASTTransformation implements ASTTransformation {

    @Override
    void visit(ASTNode[] nodes, SourceUnit sourceUnit) {
        ClassCodeExpressionTransformer trn = new ClassCodeExpressionTransformer() {         <i class="conum" data-value="1"></i><b>(1)</b>
            private boolean inArgList = false
            @Override
            protected SourceUnit getSourceUnit() {
                sourceUnit                                                                  <i class="conum" data-value="2"></i><b>(2)</b>
            }

            @Override
            Expression transform(final Expression exp) {
                if (exp instanceof ArgumentListExpression) {
                    inArgList = true
                } else if (inArgList &amp;&amp;
                    exp instanceof ConstantExpression &amp;&amp; exp.value instanceof String) {
                    return new ConstantExpression(exp.value.toUpperCase())                  <i class="conum" data-value="3"></i><b>(3)</b>
                }
                def trn = super.transform(exp)
                inArgList = false
                trn
            }
        }
        trn.visitMethod((MethodNode)nodes[1])                                               <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Internally the transformation creates a <code>ClassCodeExpressionTransformer</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The transformer needs to return the source unit</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>if a constant expression of type string is detected inside an argument list, transform it into its upper case version</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>call the transformer on the method being annotated</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_ast_nodes"><a class="anchor" href="#_ast_nodes"></a>AST Nodes</h5>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Writing an AST transformation requires a deep knowledge of the internal Groovy API. In particular it requires
knowledge about the AST classes. Since those classes are internal, there are chances that the API will change in the
future, meaning that your transformations <em>could</em> break. Despite that warning, the AST has been very stable over time
and such a thing rarely happens.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Classes of the Abstract Syntax Tree belong to the <code>org.codehaus.groovy.ast</code> package. It is recommended to the reader
to use the Groovy Console, in particular the AST browser tool, to gain knowledge about those classes. However, a good
resource for learning is the <a href="https://github.com/apache/groovy/tree/master/src/test/org/codehaus/groovy/ast/builder">AST Builder</a>
test suite.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_macros"><a class="anchor" href="#_macros"></a>2.2.5. Macros</h4>
<div class="sect4">
<h5 id="_introduction"><a class="anchor" href="#_introduction"></a>Introduction</h5>
<div class="paragraph">
<p>Until version 2.5.0, when developing AST transformations, developers should have a deep knowledge about how the AST
(Abstract Syntax Tree) was built by the compiler in order to know how to add new expressions or statements during
compile time.</p>
</div>
<div class="paragraph">
<p>Although the use of <code>org.codehaus.groovy.ast.tool.GeneralUtils</code> static methods could mitigate the burden of creating
expressions and statements, it&#8217;s still a low-level way of writing those AST nodes directly.
We needed something to abstract us from writing the AST directly and that&#8217;s exactly what Groovy macros were made for.
They allow you to directly add code during compilation, without having to translate the code you had in mind to the
<code>org.codehaus.groovy.ast.*</code> node related classes.</p>
</div>
</div>
<div class="sect4">
<h5 id="_statements_and_expressions"><a class="anchor" href="#_statements_and_expressions"></a>Statements and expressions</h5>
<div class="paragraph">
<p>Let&#8217;s see an example, lets create a local AST transformation: <code>@AddMessageMethod</code>. When applied to a given class it
will add a new method called <code>getMessage</code> to that class. The method will return "42". The annotation is pretty
straight forward:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Retention(RetentionPolicy.SOURCE)
@Target([ElementType.TYPE])
@GroovyASTTransformationClass(["metaprogramming.AddMethodASTTransformation"])
@interface AddMethod { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>What would the AST transformation look like without the use of a macro ? Something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@GroovyASTTransformation(phase = CompilePhase.INSTRUCTION_SELECTION)
class AddMethodASTTransformation extends AbstractASTTransformation {
    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        ClassNode classNode = (ClassNode) nodes[1]

        ReturnStatement code =
                new ReturnStatement(                              <i class="conum" data-value="1"></i><b>(1)</b>
                        new ConstantExpression("42"))             <i class="conum" data-value="2"></i><b>(2)</b>

        MethodNode methodNode =
                new MethodNode(
                        "getMessage",
                        ACC_PUBLIC,
                        ClassHelper.make(String),
                        [] as Parameter[],
                        [] as ClassNode[],
                        code)                                     <i class="conum" data-value="3"></i><b>(3)</b>

        classNode.addMethod(methodNode)                           <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create a return statement</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Create a constant expression "42"</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Adding the code to the new method</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Adding the new method to the annotated class</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you&#8217;re not used to the AST API, that definitely doesn&#8217;t look like the code you had in mind. Now look how the
previous code simplifies with the use of macros.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@GroovyASTTransformation(phase = CompilePhase.INSTRUCTION_SELECTION)
class AddMethodWithMacrosASTTransformation extends AbstractASTTransformation {
    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        ClassNode classNode = (ClassNode) nodes[1]

        ReturnStatement simplestCode = macro { return "42" }   <i class="conum" data-value="1"></i><b>(1)</b>

        MethodNode methodNode =
                new MethodNode(
                        "getMessage",
                        ACC_PUBLIC,
                        ClassHelper.make(String),
                        [] as Parameter[],
                        [] as ClassNode[],
                        simplestCode)                          <i class="conum" data-value="2"></i><b>(2)</b>

        classNode.addMethod(methodNode)                        <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Much simpler. You wanted to add a return statement that returned "42" and that&#8217;s exactly what you can read inside
the <code>macro</code> utility method. Your plain code will be translated for you to a <code>org.codehaus.groovy.ast.stmt.ReturnStatement</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Adding the return statement to the new method</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Adding the new code to the annotated class</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Although the <code>macro</code> method is used in this example to create a <strong>statement</strong> the <code>macro</code> method could also be used to create
<strong>expressions</strong> as well, it depends on which <code>macro</code> signature you use:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>macro(Closure)</code>: Create a given statement with the code inside the closure.</p>
</li>
<li>
<p><code>macro(Boolean,Closure)</code>: if <strong>true</strong> wrap expressions inside the closure inside an statement, if <strong>false</strong> then return
an expression</p>
</li>
<li>
<p><code>macro(CompilePhase, Closure)</code>: Create a given statement with the code inside the closure in a specific compile phase</p>
</li>
<li>
<p><code>macro(CompilePhase, Boolean, Closure)</code>: Create an statement or an expression (true == statement, false == expression)
in a specific compilation phase.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
All these signatures can be found at <code>org.codehaus.groovy.macro.runtime.MacroGroovyMethods</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sometimes we could be only interested in creating a given expression, not the whole statement, in order to do that we
should use any of the <code>macro</code> invocations with a boolean parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@GroovyASTTransformation(phase = CompilePhase.INSTRUCTION_SELECTION)
class AddGetTwoASTTransformation extends AbstractASTTransformation {

    BinaryExpression onePlusOne() {
        return macro(false) { 1 + 1 }                                      <i class="conum" data-value="1"></i><b>(1)</b>
    }

    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        ClassNode classNode = nodes[1]
        BinaryExpression expression = onePlusOne()                         <i class="conum" data-value="2"></i><b>(2)</b>
        ReturnStatement returnStatement = GeneralUtils.returnS(expression) <i class="conum" data-value="3"></i><b>(3)</b>

        MethodNode methodNode =
                new MethodNode("getTwo",
                        ACC_PUBLIC,
                        ClassHelper.Integer_TYPE,
                        [] as Parameter[],
                        [] as ClassNode[],
                        returnStatement                                    <i class="conum" data-value="4"></i><b>(4)</b>
                )

        classNode.addMethod(methodNode)                                    <i class="conum" data-value="5"></i><b>(5)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We&#8217;re telling macro not to wrap the expression in a statement, we&#8217;re only interested in the expression</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Assigning the expression</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Creating a <code>ReturnStatement</code> using a method from <code>GeneralUtils</code> and returning the expression</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Adding the code to the new method</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Adding the method to the class</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_variable_substitution"><a class="anchor" href="#_variable_substitution"></a>Variable substitution</h5>
<div class="paragraph">
<p>Macros are great but we can&#8217;t create anything useful or reusable if our macros couldn&#8217;t receive parameters or resolve
surrounding variables.</p>
</div>
<div class="paragraph">
<p>In the following example we&#8217;re creating an AST transformation <code>@MD5</code> that when applied to a given String field will
add a method returning the MD5 value of that field.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Retention(RetentionPolicy.SOURCE)
@Target([ElementType.FIELD])
@GroovyASTTransformationClass(["metaprogramming.MD5ASTTransformation"])
@interface MD5 { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the transformation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@GroovyASTTransformation(phase = CompilePhase.CANONICALIZATION)
class MD5ASTTransformation extends AbstractASTTransformation {

    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        FieldNode fieldNode = nodes[1]
        ClassNode classNode = fieldNode.declaringClass
        String capitalizedName = fieldNode.name.capitalize()
        MethodNode methodNode = new MethodNode(
                "get${capitalizedName}MD5",
                ACC_PUBLIC,
                ClassHelper.STRING_TYPE,
                [] as Parameter[],
                [] as ClassNode[],
                buildMD5MethodCode(fieldNode))

        classNode.addMethod(methodNode)
    }

    BlockStatement buildMD5MethodCode(FieldNode fieldNode) {
        VariableExpression fieldVar = GeneralUtils.varX(fieldNode.name) <i class="conum" data-value="1"></i><b>(1)</b>

        return macro(CompilePhase.SEMANTIC_ANALYSIS, true) {            <i class="conum" data-value="2"></i><b>(2)</b>
            return java.security.MessageDigest
                    .getInstance('MD5')
                    .digest($v { fieldVar }.getBytes())                 <i class="conum" data-value="3"></i><b>(3)</b>
                    .encodeHex()
                    .toString()
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We need a reference to a variable expression</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If using a class outside the standard packages we should add any needed imports or use the qualified name. When
using the qualified named of a given static method you need to make sure it&#8217;s resolved in the proper compile phase. In
this particular case we&#8217;re instructing the macro to resolve it at the SEMANTIC_ANALYSIS phase, which is the first compile phase
with type information.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>In order to substitute any <code>expression</code> inside the macro we need to use the <code>$v</code> method. <code>$v</code> receives a closure as an
argument, and the closure is only allowed to substitute expressions, meaning classes inheriting
<code>org.codehaus.groovy.ast.expr.Expression</code>.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_macroclass"><a class="anchor" href="#_macroclass"></a>MacroClass</h5>
<div class="paragraph">
<p>As we mentioned earlier, the <code>macro</code> method is only capable of producing <code>statements</code> and <code>expressions</code>. But what if we
want to produce other types of nodes, such as a method, a field and so on?</p>
</div>
<div class="paragraph">
<p><code>org.codehaus.groovy.macro.transform.MacroClass</code> can be used to create <strong>classes</strong> (ClassNode instances) in our
transformations the same way we created statements and expressions with the <code>macro</code> method before.</p>
</div>
<div class="paragraph">
<p>The next example is a local transformation <code>@Statistics</code>. When applied to a given class, it will add two methods
<strong>getMethodCount()</strong> and <strong>getFieldCount()</strong> which return how many methods and fields within the class respectively. Here
is the marker annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Retention(RetentionPolicy.SOURCE)
@Target([ElementType.TYPE])
@GroovyASTTransformationClass(["metaprogramming.StatisticsASTTransformation"])
@interface Statistics {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the AST transformation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@CompileStatic
@GroovyASTTransformation(phase = CompilePhase.INSTRUCTION_SELECTION)
class StatisticsASTTransformation extends AbstractASTTransformation {

    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        ClassNode classNode = (ClassNode) nodes[1]
        ClassNode templateClass = buildTemplateClass(classNode)  <i class="conum" data-value="1"></i><b>(1)</b>

        templateClass.methods.each { MethodNode node -&gt;          <i class="conum" data-value="2"></i><b>(2)</b>
            classNode.addMethod(node)
        }
    }

    @CompileDynamic
    ClassNode buildTemplateClass(ClassNode reference) {          <i class="conum" data-value="3"></i><b>(3)</b>
        def methodCount = constX(reference.methods.size())       <i class="conum" data-value="4"></i><b>(4)</b>
        def fieldCount = constX(reference.fields.size())         <i class="conum" data-value="5"></i><b>(5)</b>

        return new MacroClass() {
            class Statistics {
                java.lang.Integer getMethodCount() {             <i class="conum" data-value="6"></i><b>(6)</b>
                    return $v { methodCount }
                }

                java.lang.Integer getFieldCount() {              <i class="conum" data-value="7"></i><b>(7)</b>
                    return $v { fieldCount }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Creating a template class</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Adding template class methods to the annotated class</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Passing the reference class</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Extracting reference class method count value expression</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Extracting reference class field count value expression</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Building the <strong>getMethodCount()</strong> method using reference&#8217;s method count value expression</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Building the <strong>getFieldCount()</strong> method using reference&#8217;s field count value expression</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Basically we&#8217;ve created the <strong>Statistics</strong> class as a template to avoid writing low level AST API, then we
copied methods created in the template class to their final destination.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Types inside the <code>MacroClass</code> implementation should be resolved inside, that&#8217;s why we had to write
<code>java.lang.Integer</code> instead of simply writing <code>Integer</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Notice that we&#8217;re using <code>@CompileDynamic</code>. That&#8217;s because the way we use <code>MacroClass</code> is like we
were actually implementing it. So if you were using <code>@CompileStatic</code> it will complain because an implementation of
an abstract class can&#8217;t be another different class.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_macro_methods"><a class="anchor" href="#_macro_methods"></a>@Macro methods</h5>
<div class="paragraph">
<p>You have seen that by using <code>macro</code> you can save yourself a lot of work but you might wonder where
that method came from. You didn&#8217;t declare it or static import it. You can think of it as a special
global method (or if you prefer, a method on every <code>Object</code>). This is much like how the <code>println</code>
extension method is defined. But unlike <code>println</code> which becomes a method selected for execution
later in the compilation process, <code>macro</code> expansion is done early in the compilation process.
The declaration of <code>macro</code> as one of the available methods for this early expansion is done
by annotating a <code>macro</code> method definition with the <code>@Macro</code> annotation and making that method
available using a similar mechanism for extension modules. Such methods are known as <em>macro</em> methods
and the good news is you can define your own.</p>
</div>
<div class="paragraph">
<p>To define your own macro method, create a class in a similar way to an extension module and
add a method such as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">public class ExampleMacroMethods {

    @Macro
    public static Expression safe(MacroContext macroContext, MethodCallExpression callExpression) {
        return ternaryX(
                notNullX(callExpression.getObjectExpression()),
                callExpression,
                constX(null)
        );
    }
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you would register this as an extension module using a <code>org.codehaus.groovy.runtime.ExtensionModule</code>
file within the <code>META-INF/groovy</code> directory.</p>
</div>
<div class="paragraph">
<p>Now, assuming that the class and meta info file are on your classpath, you can use the
macro method in the following way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def nullObject = null
assert null == safe(safe(nullObject.hashcode()).toString())</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_testing_ast_transformations"><a class="anchor" href="#_testing_ast_transformations"></a>2.2.6. Testing AST transformations</h4>
<div class="sect4">
<h5 id="_separating_source_trees"><a class="anchor" href="#_separating_source_trees"></a>Separating source trees</h5>
<div class="paragraph">
<p>This section is about good practices with regards to testing AST transformations. Previous sections highlighted the fact
that to be able to execute an AST transformation, it has to be precompiled. It might sound obvious but a lot of people
get caught on this, trying to use an AST transformation in the same source tree as where it is defined.</p>
</div>
<div class="paragraph">
<p>The first tip for testing AST transformation is therefore to separate test sources from the sources of the transform.
Again, this is nothing but best practices, but you must make sure that your build too does actually compile them separately.
This is the case by default with both <a href="http://maven.apache.org">Apache Maven</a> and <a href="http://gradle.org">Gradle</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_debugging_ast_transformations"><a class="anchor" href="#_debugging_ast_transformations"></a>Debugging AST transformations</h5>
<div class="paragraph">
<p>It is very handy to be able to put a breakpoint in an AST transformation, so that you can debug your code in the IDE.
However, you might be surprised to see that your IDE doesn&#8217;t stop on the breakpoint. The reason is actually simple: if
your IDE uses the Groovy compiler to compile the unit tests for your AST transformation, then the compilation is triggered
from the IDE, but the process which will compile the files doesn&#8217;t have debugging options. It&#8217;s only when the test case
is executed that the debugging options are set on the virtual machine. In short: it is too late, the class has been compiled
already, and your transformation is already applied.</p>
</div>
<div class="paragraph">
<p>A very easy workaround is to use the <code>GroovyTestCase</code> class which provides an <code>assertScript</code> method. This means that
instead of writing this in a test case:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">static class Subject {
    @MyTransformToDebug
    void methodToBeTested() {}
}

void testMyTransform() {
    def c = new Subject()
    c.methodToBeTested()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void testMyTransformWithBreakpoint() {
    assertScript '''
        import metaprogramming.MyTransformToDebug

        class Subject {
            @MyTransformToDebug
            void methodToBeTested() {}
        }
        def c = new Subject()
        c.methodToBeTested()
    '''
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The difference is that when you use <code>assertScript</code>, the code in the <code>assertScript</code> block is compiled <strong>when the
unit test is executed</strong>. That is to say that this time, the <code>Subject</code> class will be compiled with debugging active, and
the breakpoint is going to be hit.</p>
</div>
</div>
<div class="sect4">
<h5 id="_astmatcher"><a class="anchor" href="#_astmatcher"></a>ASTMatcher</h5>
<div class="paragraph">
<p>Sometimes you may want to make assertions over AST nodes; perhaps to filter the nodes, or to make sure a given
transformation has built the expected AST node.</p>
</div>
<div class="paragraph">
<p><strong>Filtering nodes</strong></p>
</div>
<div class="paragraph">
<p>For instance if you would like to apply a given transformation only to a specific set of AST nodes, you could
use <strong>ASTMatcher</strong> to filter these nodes. The following example shows how to transform a given expression to
another. Using <strong>ASTMatcher</strong> it looks for a specific expression <code>1 + 1</code> and it transforms it to <code>3</code>. That&#8217;s why
we called it the <code>@Joking</code> example.</p>
</div>
<div class="paragraph">
<p>First we create the <code>@Joking</code> annotation that only can be applied to methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@Retention(RetentionPolicy.SOURCE)
@Target([ElementType.METHOD])
@GroovyASTTransformationClass(["metaprogramming.JokingASTTransformation"])
@interface Joking { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the transformation, that only applies an instance of <code>org.codehaus.groovy.ast.ClassCodeExpressionTransformer</code>
to all the expressions within the method code block.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@CompileStatic
@GroovyASTTransformation(phase = CompilePhase.INSTRUCTION_SELECTION)
class JokingASTTransformation extends AbstractASTTransformation {
    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        MethodNode methodNode = (MethodNode) nodes[1]

        methodNode
            .getCode()
            .visit(new ConvertOnePlusOneToThree(source))  <i class="conum" data-value="1"></i><b>(1)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Get the method&#8217;s code statement and apply the expression transformer</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And this is when the <strong>ASTMatcher</strong> is used to apply the transformation only to those expressions matching
the expression <code>1 + 1</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class ConvertOnePlusOneToThree extends ClassCodeExpressionTransformer {
    SourceUnit sourceUnit

    ConvertOnePlusOneToThree(SourceUnit sourceUnit) {
        this.sourceUnit = sourceUnit
    }

    @Override
    Expression transform(Expression exp) {
        Expression ref = macro { 1 + 1 }     <i class="conum" data-value="1"></i><b>(1)</b>

        if (ASTMatcher.matches(ref, exp)) {  <i class="conum" data-value="2"></i><b>(2)</b>
            return macro { 3 }               <i class="conum" data-value="3"></i><b>(3)</b>
        }

        return super.transform(exp)
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Builds the expression used as reference pattern</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Checks the current expression evaluated matches the reference expression</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>If it matches then replaces the current expression with the expression built with <code>macro</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Then you could test the implementation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">package metaprogramming

class Something {
    @Joking
    Integer getResult() {
        return 1 + 1
    }
}

assert new Something().result == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Unit testing AST transforms</strong></p>
</div>
<div class="paragraph">
<p>Normally we test AST transformations just checking that the final use of the transformation does what we expect. But
it would be great if we could have an easy way to check, for example, that the nodes the transformation adds are what
we expected from the beginning.</p>
</div>
<div class="paragraph">
<p>The following transformation adds a new method <code>giveMeTwo</code> to an annotated class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@GroovyASTTransformation(phase = CompilePhase.INSTRUCTION_SELECTION)
class TwiceASTTransformation extends AbstractASTTransformation {

    static final String VAR_X = 'x'

    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        ClassNode classNode = (ClassNode) nodes[1]
        MethodNode giveMeTwo = getTemplateClass(sumExpression)
            .getDeclaredMethods('giveMeTwo')
            .first()

        classNode.addMethod(giveMeTwo)                  <i class="conum" data-value="1"></i><b>(1)</b>
    }

    BinaryExpression getSumExpression() {               <i class="conum" data-value="2"></i><b>(2)</b>
        return macro {
            $v{ varX(VAR_X) } +
            $v{ varX(VAR_X) }
        }
    }

    ClassNode getTemplateClass(Expression expression) { <i class="conum" data-value="3"></i><b>(3)</b>
        return new MacroClass() {
            class Template {
                java.lang.Integer giveMeTwo(java.lang.Integer x) {
                    return $v { expression }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Adding the method to the annotated class</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Building a binary expression. The binary expression uses the same variable expression in both
sides of the <code>+</code> token (check <code>varX</code> method at <strong>org.codehaus.groovy.ast.tool.GeneralUtils</strong>).</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Builds a new <strong>ClassNode</strong> with a method called <code>giveMeTwo</code> which returns the result of an expression
passed as parameter.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now instead of creating a test executing the transformation over a given sample code. I would like to check that
the construction of the binary expression is done properly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void testTestingSumExpression() {
    use(ASTMatcher) {                 <i class="conum" data-value="1"></i><b>(1)</b>
        TwiceASTTransformation sample = new TwiceASTTransformation()
        Expression referenceNode = macro {
            a + a                     <i class="conum" data-value="2"></i><b>(2)</b>
        }.withConstraints {           <i class="conum" data-value="3"></i><b>(3)</b>
            placeholder 'a'           <i class="conum" data-value="4"></i><b>(4)</b>
        }

        assert sample
            .sumExpression
            .matches(referenceNode)   <i class="conum" data-value="5"></i><b>(5)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using ASTMatcher as a category</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Build a template node</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Apply some constraints to that template node</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Tells compiler that <code>a</code> is a placeholder.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Asserts reference node and current node are equal</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Of course you can/should always check the actual execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void testASTBehavior() {
    assertScript '''
    package metaprogramming

    @Twice
    class AAA {

    }

    assert new AAA().giveMeTwo(1) == 2
    '''
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_asttest"><a class="anchor" href="#_asttest"></a>ASTTest</h5>
<div class="paragraph">
<p>Last but not least, testing an AST transformation is also about testing the state of the AST <strong>during compilation</strong>. Groovy
provides a tool named <code>@ASTTest</code> for this: it is an annotation that will let you add assertions on an abstract syntax
tree. Please check the <a href="#xform-ASTTest">documentation for ASTTest</a> for more details.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_external_references"><a class="anchor" href="#_external_references"></a>2.2.7. External references</h4>
<div class="paragraph">
<p>If you are interested in a step-by-step tutorial about writing AST transformations, you can follow
<a href="http://melix.github.io/ast-workshop/">this workshop</a>.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 3.0.3<br>
Last updated 2020-04-07 16:15:40 AEST
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>
</body>
</html>